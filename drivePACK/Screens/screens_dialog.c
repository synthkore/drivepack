// *****************************************************************
// ****                       drivePACK                         ****
// ****                  www.tolaemon.com/dpack                 ****
// ****                       Source code                       ****
// ****                       10/11/2021                        ****
// ****                     Jordi Bartolome                     ****
// ****                                                         ****
// **** IMPORTANT:                                              ****
// **** Using this code or any part of it means accepting all   ****
// **** conditions exposed in: http://www.tolaemon.com/dpack    ****
// *****************************************************************

#include "screens_dialog.h"

// references to external structures
extern struct ref_screens_control screens_control;
extern struct ref_screens_enter_txt screens_enter_txt;

struct ref_screens_dialog screens_dialog;

// declare extern structures
extern uint8_t ui8_dpack_dumper_nibbles_buffer[MAX_ROM_NIBBLES_BUFFER];
extern uint8_t ui8_dpack_dumper_buffer_initialized;
extern uint8_t ui8_dpack_title_buffer[MAX_ROM_TITLE_BUFFER];
extern uint8_t ui8_dpack_songs_info_buffer[MAX_ROM_SONGS_INFO_BUFFER];
extern uint8_t ui8_dpack_file_name[MAX_ROM_FILE_NAME];
extern uint8_t ui8_dpack_file_path[MAX_ROM_FILE_PATH];
extern uint8_t ui8_usart_1kX_retries;

// declare extern assembly public functions
extern void dpack_int_main(void);
extern void dpack_dumper_main(void);
extern void config_ctrl_lines_as_input(void);
extern void config_data_lines_as_input(void);
extern void config_ctrl_lines_as_output(void);
extern void config_data_lines_as_output(void);

const uint16_t img_size[]={158,73};//size
const uint16_t img_data[]={
	0xFFFE,0x009E,0xDDD6,0xFFFE,0x00A4,0xFFFF,0xF79E,0xF79E,0xFFFE,0x0004,0xFFFF,0xF79E,0xF79E,0xFFFF,0xFFFF,0xEF5D,0xF7BE,0xFFFE,0x0003,0xFFFF,
	0xEF5D,0xEF5D,0xFFFE,0x0005,0xFFFF,0xF7BE,0xD6BA,0xEF5D,0xFFDF,0xFFFF,0xEF5D,0xF7BE,0xFFFF,0xFFFF,0xEF5D,0xF79E,0xD6BA,0xFFFE,0x0004,0xFFFF,
	0xC638,0xF7BE,0xD6BA,0xFFFE,0x0003,0xFFFF,0xF79E,0xF7DE,0xFFFF,0xFFFF,0xF7BE,0xEF5D,0xEF5D,0xF7DE,0xFFFF,0xFFFF,0xF7BE,0xF7BE,0xFFFF,0xFFFF,
	0xFFDF,0xEF5D,0xF7BE,0xD6BA,0xFFFE,0x0004,0xFFFF,0xC638,0xFFDF,0xD6BA,0xC638,0xD6BA,0xF7DE,0xFFFF,0xFFFF,0xEF5D,0xFFFE,0x0003,0xC638,0xF7BE,
	0xF7DE,0xFFFE,0x0004,0xC638,0xFFDF,0xFFFE,0x0005,0xFFFF,0xC638,0xD6BA,0xEF5D,0xFFFE,0x0004,0xFFFF,0xC638,0xFFFF,0xFFFF,0xF7DE,0xD6BA,0xFFFF,
	0xEF7D,0xF79E,0xFFFE,0x0003,0xFFFF,0xEF5D,0xF7DE,0xFFFF,0xFFFF,0xF7BE,0xFFFE,0x0003,0xC638,0xD6BA,0xFFFE,0x0005,0xFFFF,0xF7BE,0xEF5D,0xFFFE,
	0x0003,0xFFFF,0xEF7D,0xF79E,0xFFFE,0x0003,0xFFFF,0xF7BE,0xEF5D,0xFFFF,0xFFFF,0xF79E,0xD6BA,0xF79E,0xFFFF,0xF7BE,0xEF7D,0xFFFF,0xFFFF,0xEF7D,
	0xEF5D,0xFFFE,0x000C,0xFFFF,0x7BCF,0x7BEF,0xFFFE,0x0004,0xFFFF,0x7BEF,0x7BEF,0xFFFF,0xEF5D,0x18A3,0xEF5D,0xFFFF,0xB5F6,0x2965,0x4208,0x31C6,
	0x4A49,0xEF5D,0xFFFF,0xF7DE,0x738E,0x18A3,0x4A69,0x3186,0x31C6,0xFFFF,0x528A,0xA514,0xFFFF,0xB5D6,0x2945,0xEF5D,0x0000,0xAD75,0xB5F6,0xB5F6,
	0x9CB3,0x20C4,0xF7BE,0x0861,0xB5F6,0xFFFF,0xFFFF,0x31C6,0x8C91,0xFFFF,0xFFFF,0x7BEF,0x738E,0x4A69,0x9CD3,0xFFFF,0xFFFF,0x736E,0x6B4D,0xFFFF,
	0xFFFF,0xA514,0x4208,0xEF7D,0x0000,0xAD75,0xB5F6,0xB5F6,0x9CB3,0x20E4,0xF7BE,0x0000,0x4A49,0x4A69,0x18A3,0xA514,0xFFFF,0x4A49,0x2965,0x528A,
	0x528A,0xA554,0xC5F8,0x0000,0xFFFE,0x0003,0x528A,0xEF5D,0xFFFE,0x0004,0xFFFF,0xF7DE,0x0000,0x4A49,0x4208,0x2124,0x9D13,0xFFFF,0xF79E,0x0000,
	0xF7DE,0xFFFF,0x738E,0x8410,0xFFFF,0x736E,0x8430,0xFFFF,0xFFFF,0xEF7D,0x0000,0x8C71,0xFFFF,0xFFFF,0xA534,0x0000,0xFFFE,0x0003,0x528A,0xFFDF,
	0xFFFE,0x0004,0xFFFF,0x9CD3,0x52AA,0xFFFE,0x0003,0xFFFF,0x9CD3,0x4208,0xFFFE,0x0003,0xB5F6,0x52AA,0x8430,0xF7DE,0x5B2B,0x18A3,0x528A,0x31C6,
	0xF7DE,0x8470,0x5ACB,0xFFFF,0xC5F8,0x0000,0xA534,0xFFFE,0x000C,0xFFFF,0x7BCF,0x7BEF,0xFFFE,0x0004,0xFFFF,0x7BEF,0x7BEF,0xFFFF,0x4A69,0x8CB1,
	0xFFFF,0xF7DE,0x18A3,0xAD55,0xFFFF,0xFFFF,0x8430,0x4A69,0xFFFF,0x8410,0x528A,0xF7BE,0xFFFF,0xB596,0x2945,0xFFFF,0x528A,0xA514,0xF7BE,0x20E4,
	0xB596,0xFFFF,0x6B4D,0x18C3,0x6B2D,0x6B2D,0x0000,0x8C71,0xFFFF,0x8410,0x738E,0xFFFF,0xC618,0x0000,0x2945,0xFFFF,0xF7DE,0x18C3,0xC618,0xA554,
	0x4208,0xFFFF,0xF7BE,0x0020,0x0000,0xF79E,0xFFFF,0x4A69,0xA534,0xFFFF,0x6B2D,0x18C3,0x6B2D,0x6B2D,0x0000,0x8C71,0xFFDF,0x0000,0xEF7D,0xFFFF,
	0xC618,0x0000,0xFFDF,0x4A49,0xA534,0xFFFE,0x0003,0xFFFF,0xC5F8,0x0020,0xFFFE,0x0008,0xFFFF,0xF7DE,0x0000,0xF79E,0xFFFF,0xEF5D,0x18C3,0xAD75,
	0xF79E,0x0000,0xF7DE,0xAD75,0x2124,0xF7DE,0xFFFF,0x738E,0x8430,0xFFFF,0xFFFF,0x8C71,0x18C3,0x2124,0xFFFF,0xFFFF,0xA534,0x4A49,0xFFFE,0x0008,
	0xFFFF,0x9CD3,0x52AA,0xFFFE,0x0003,0xFFFF,0xF7BE,0x0000,0x4A49,0x6B2D,0x528A,0x0000,0xEF5D,0x8430,0x4A49,0xF7DE,0xFFFE,0x0003,0xFFFF,0x8C71,
	0x5ACB,0xEF5D,0x0881,0x8C91,0xFFFE,0x000D,0xFFFF,0x7BCF,0x52AA,0xA534,0xB5F6,0xFFFF,0xFFFF,0x7BEF,0x528A,0x7BCF,0x18A3,0xF7BE,0xFFFF,0xB5D6,
	0x20E4,0xFFFE,0x0003,0xFFFF,0xF7BE,0x0000,0xF79E,0x2124,0xAD95,0xFFFF,0x8C71,0x52AA,0x2945,0xFFFF,0x528A,0x736E,0x5AEB,0x4A49,0xFFFF,0xFFFF,
	0xB5D6,0x18C3,0xFFDF,0xF79E,0x0000,0xEF5D,0xFFFF,0xC618,0x0020,0xF7DE,0x7BCF,0x8410,0x2925,0xB5D6,0xAD75,0x3186,0xFFFF,0xF7BE,0x0000,0xD6BA,
	0x9CD3,0x5ACB,0x5AEB,0x9CD3,0xEF5D,0x0020,0xF7BE,0xFFFF,0xB5D6,0x18C3,0xFFDF,0xF79E,0x0000,0xEF5D,0xFFDF,0x0000,0xB5D6,0xD6BA,0x8C91,0x20E4,
	0xFFDF,0x4A49,0xA534,0xFFFE,0x0003,0xFFFF,0xC5F8,0x0000,0xD6BA,0xD6BA,0xF79E,0xFFFE,0x0005,0xFFFF,0xF7DE,0x0000,0xF79E,0xFFFF,0xFFFF,0x8C71,
	0x6B4D,0xF79E,0x0000,0x9CD3,0x0881,0x9CD3,0xFFFF,0xFFFF,0x738E,0x8430,0xFFFF,0xFFFF,0x2945,0xAD55,0x18A3,0xB5D6,0xFFFF,0xA534,0x31C6,0xD6BA,
	0xD6BA,0xF7BE,0xFFFE,0x0005,0xFFFF,0x9CD3,0x3186,0xA534,0xB5D6,0xF7DE,0xFFFF,0x736E,0x8410,0xFFFF,0x9CB3,0x52AA,0xFFFF,0x41E8,0xA554,0xFFFE,
	0x0004,0xFFFF,0x8C71,0x4208,0x2945,0x7BEF,0xFFFE,0x000E,0xFFFF,0x7BCF,0x4208,0x8430,0x4A69,0x4A69,0xFFDF,0x7BEF,0x41E8,0x8430,0x52AA,0x41E8,
	0xF7DE,0xB596,0x2965,0xFFFE,0x0003,0xFFFF,0xFFDF,0x0000,0xEF7D,0x18C3,0xB5D6,0xFFFF,0xC5F8,0xB596,0xB5D6,0xFFFF,0x528A,0x5ACB,0x8430,0x41E8,
	0x6B2D,0xFFFF,0xFFFF,0x2965,0xB596,0x9CD3,0x5ACB,0xFFFE,0x0003,0xFFFF,0x41E8,0xA534,0x0020,0xC618,0x8430,0x736E,0x6B4D,0x8C91,0xFFFF,0xFFFF,
	0x736E,0x8430,0x4208,0xA534,0xAD55,0x31C6,0x8C71,0x6B4D,0xFFFE,0x0003,0xFFFF,0x2945,0xB596,0x9CB3,0x5AEB,0xFFFF,0xFFDF,0x0000,0x4208,0x4A69,
	0x0000,0xAD55,0xFFFF,0x4A49,0xA534,0xFFFE,0x0003,0xFFFF,0xC5F8,0x0000,0x4A69,0x4A69,0x9CD3,0xFFFE,0x0005,0xFFFF,0xF7DE,0x0000,0xF79E,0xFFFF,
	0xFFFF,0x9CD3,0x5AEB,0xF79E,0x0000,0x8410,0x7BEF,0x18A3,0xAD55,0xFFFF,0x738E,0x8430,0xFFFF,0xB5D6,0x0020,0xFFDF,0x7BEF,0x6B4D,0xFFFF,0xA534,
	0x0000,0x4A69,0x4A69,0xAD75,0xFFFE,0x0005,0xFFFF,0x9CD3,0x2124,0x8430,0x5AEB,0x2965,0xF7BE,0xB5F6,0x18C3,0xFFDF,0x41E8,0xAD75,0xFFFF,0x31C6,
	0xAD75,0xFFFE,0x0004,0xFFFF,0x8C71,0x18A3,0x0000,0xB5D6,0xFFFE,0x000E,0xFFFF,0x7BCF,0x7BEF,0xFFFF,0xFFDF,0x0861,0xC5F8,0x7BEF,0x7BEF,0xFFFF,
	0xFFFF,0x1883,0xB5D6,0xEF7D,0x0000,0xEF5D,0xFFFF,0xFFFF,0xAD95,0x18C3,0xFFDF,0x736E,0x736E,0xFFFE,0x0005,0xFFFF,0x528A,0xA514,0xFFFF,0xF79E,
	0x0000,0xF7BE,0xFFFF,0x8CB1,0x6B4D,0x41E8,0xAD95,0xFFFE,0x0003,0xFFFF,0x9CD3,0x18C3,0x31C6,0xFFFF,0xC638,0x0000,0x18C3,0xEF7D,0xFFFF,0xFFFF,
	0xB5D6,0x18C3,0x0000,0xF7BE,0xF7DE,0x0000,0x20E4,0xB5D6,0xFFFE,0x0003,0xFFFF,0x8C91,0x6B4D,0x41E8,0xB596,0xFFFF,0xFFDF,0x0000,0xEF7D,0xFFFF,
	0xA514,0x4A49,0xFFFF,0x4A49,0xA534,0xFFFE,0x0003,0xFFFF,0xC5F8,0x0020,0xFFFE,0x0008,0xFFFF,0xF7DE,0x0000,0xF79E,0xFFFF,0xFFFF,0x528A,0x8C91,
	0xF79E,0x0000,0xF7DE,0xFFFF,0x9CB3,0x5ACB,0xFFFF,0x738E,0x8430,0xFFFF,0x6B4D,0x7BCF,0xFFFF,0xC618,0x0000,0xF7BE,0xA534,0x4A49,0xFFFE,0x0008,
	0xFFFF,0x9CD3,0x52AA,0xFFFF,0xFFFF,0x4A49,0xC618,0xFFFF,0x3186,0x8C91,0x18A3,0xFFDF,0xFFFF,0x7BCF,0x736E,0xFFFE,0x0004,0xFFFF,0x8C71,0x5ACB,
	0x9CD3,0x0881,0xEF5D,0xFFFE,0x000D,0xFFFF,0x7BCF,0x52AA,0xA534,0x7BEF,0x1883,0xF7BE,0x7BEF,0x528A,0xA534,0x8410,0x0861,0xF7BE,0xFFFF,0x8470,
	0x2965,0x9CD3,0x8C91,0x18A3,0xAD55,0xFFFF,0xEF7D,0x2965,0x5ACB,0x9D13,0x9CD3,0xC5F8,0xFFFF,0x528A,0x736E,0xA514,0x736E,0x31C6,0xFFFF,0xFFFF,
	0xF79E,0x0000,0x20E4,0xFFDF,0xFFFE,0x0003,0xFFFF,0xF7BE,0x0000,0x8CB1,0xFFFF,0xFFFF,0x41E8,0x5AEB,0xFFFE,0x0004,0xFFFF,0x2965,0x736E,0xFFFF,
	0xFFFF,0x738E,0x2945,0xFFFE,0x0004,0xFFFF,0xEF7D,0x0000,0x20E4,0xFFFF,0xFFFF,0xFFDF,0x0000,0x8CB1,0xA514,0x4A49,0x7BCF,0xFFFF,0x4A49,0xA534,
	0xFFFE,0x0003,0xFFFF,0xC5F8,0x0000,0xFFFE,0x0003,0xA534,0xFFDF,0xFFFE,0x0004,0xFFFF,0xF7DE,0x0000,0x9CB3,0x9CB3,0x4A49,0x4A69,0xF7DE,0xF79E,
	0x0000,0x9CD3,0x9CD3,0x31C6,0x8C91,0xFFFF,0x738E,0x8430,0xF7BE,0x0000,0xC5F8,0xFFFF,0xFFFF,0x31C6,0x9CD3,0xA534,0x2925,0xA534,0xA534,0xAD75,
	0xFFFE,0x0005,0xFFFF,0x9CD3,0x3186,0xA534,0x8C71,0x0020,0xEF5D,0xFFFF,0x9CD3,0x0000,0x8430,0xFFFF,0xFFFF,0xEF7D,0x20E4,0x6B4D,0xA514,0x8C91,
	0xFFFF,0x8C71,0x5ACB,0xFFFF,0x7BCF,0x31C6,0xF7BE,0xFFFE,0x000C,0xFFFF,0xAD75,0x8430,0x8430,0x9CD3,0xF79E,0xFFFF,0xAD95,0x8430,0x8430,0x9CD3,
	0xEF5D,0xFFFE,0x0003,0xFFFF,0xB5F6,0x8C71,0x8C91,0xD6BA,0xFFFE,0x0003,0xFFFF,0xF7DE,0xAD55,0x8470,0x8C91,0xEF5D,0xFFFF,0xA514,0x8430,0x8430,
	0xA514,0xF7BE,0xFFFE,0x0003,0xFFFF,0xA514,0xAD75,0xFFFE,0x0005,0xFFFF,0xA514,0xF79E,0xFFFF,0xFFFF,0xB5D6,0xC618,0xFFFE,0x0004,0xFFFF,0xAD95,
	0xC618,0xFFFF,0xFFFF,0xC638,0xB596,0xFFFE,0x0005,0xFFFF,0xA514,0xAD75,0xFFFE,0x0003,0xFFFF,0xFFFE,0x0003,0x8430,0xA554,0xFFDF,0xFFFF,0x9D13,
	0xC618,0xFFFE,0x0003,0xFFFF,0xEF7D,0xFFFE,0x0003,0x8430,0x8470,0xFFDF,0xFFFE,0x0004,0xFFFF,0xFFDF,0x8430,0x8430,0x8C91,0xB596,0xFFFF,0xFFFF,
	0xF7DE,0x8430,0x8430,0x8C71,0xB596,0xFFFF,0xFFFF,0xAD75,0xB5D6,0xC638,0x8C91,0xFFFE,0x0003,0xFFFF,0xB596,0xA534,0xC618,0xFFFE,0x0003,0x8430,
	0x9CB3,0xFFFE,0x0005,0xFFFF,0xC5F8,0x8430,0x8430,0x9CB3,0xD6BA,0xFFFF,0xFFFF,0xF7BE,0x8430,0xEF7D,0xFFFE,0x0003,0xFFFF,0xF7BE,0xA514,0x8470,
	0x9CD3,0xFFFF,0xB5D6,0xA534,0xFFFF,0xFFDF,0x8C91,0xB5D6,0xFFFE,0x00A4,0xFFFF,0xFFFE,0x009E,0xF79E,0xFFFE,0x0280,0x9CF3,0xFFFE,0x0018,0xA534,
	0xA514,0xFFFE,0x000B,0x9CF3,0xFFFE,0x0003,0x9CD3,0xA534,0xAD75,0xAD75,0xA534,0xFFFE,0x0017,0x9CF3,0xA514,0xB596,0xFFFE,0x0007,0xAD75,0xFFFE,
	0x0050,0x9CF3,0x9D13,0xAD75,0xA514,0x8C51,0xFFFE,0x0017,0x8410,0x8C71,0xA534,0xA534,0xFFFE,0x0008,0x9CF3,0x9D13,0x1082,0xFFFE,0x0004,0x0000,
	0x0861,0x9492,0xFFFE,0x0016,0x9CF3,0xAD75,0x9CD3,0x5ACB,0x18C3,0xFFFE,0x0005,0x1062,0x18E3,0xFFFE,0x0008,0x9CF3,0xA534,0xFFFE,0x0009,0xB596,
	0x9D13,0x9D13,0xFFFE,0x0014,0x9CF3,0xA514,0xB596,0xFFFE,0x0018,0xAD55,0xAD75,0xA534,0xFFFE,0x000C,0x9CF3,0xB596,0x632C,0x1082,0xFFFE,0x0019,
	0x0000,0x18E3,0x8410,0xA534,0xFFFE,0x0007,0x9CF3,0x9D13,0x10A2,0xFFFE,0x0004,0x0000,0x1082,0x9D13,0xFFFE,0x0015,0x9CF3,0xAD75,0x8C51,0x1082,
	0xFFFE,0x0007,0x0000,0x10A2,0xFFFE,0x0006,0x9CF3,0x9D13,0xB596,0x8C71,0x528A,0x39C7,0x39A7,0xFFFE,0x0007,0x31A6,0x39C7,0x6B4D,0x9CD3,0xFFFE,
	0x0011,0x9CF3,0xAD75,0x94B2,0x4A69,0x10A2,0xFFFE,0x0004,0x0020,0xFFFE,0x0013,0x0821,0x2965,0x7BCF,0xA534,0xFFFE,0x000A,0x9CF3,0xB596,0x630C,
	0xFFFE,0x001C,0x0000,0x0841,0x8C51,0xA514,0xFFFE,0x0006,0x9CF3,0x9D13,0x10A2,0xFFFE,0x0004,0x0000,0x1082,0xA534,0xFFFE,0x0014,0x9CF3,0xA514,
	0x9CF3,0x10A2,0xFFFE,0x0008,0x0000,0x10A2,0xFFFE,0x0005,0x9CF3,0x9D13,0xB596,0x528A,0x0020,0xFFFE,0x000C,0x0000,0x4A49,0x9CD3,0xFFFE,0x000F,
	0x9CF3,0xAD75,0x8430,0x1082,0xFFFE,0x001B,0x0000,0x52AA,0xA534,0xFFFE,0x0008,0x9CF3,0x9D13,0x9CD3,0x0841,0xFFFE,0x001D,0x0000,0x3186,0xAD55,
	0xFFFE,0x0006,0x9CF3,0x9D13,0x10A2,0xFFFE,0x0004,0x0000,0x1082,0xA534,0xFFFE,0x0014,0x9CF3,0xAD75,0x632C,0xFFFE,0x0009,0x0000,0x10A2,0xFFFE,
	0x0005,0x9CF3,0xB596,0x5AEB,0xFFFE,0x000F,0x0000,0x4A49,0x9CD3,0xFFFE,0x000D,0x9CF3,0xA514,0x9D13,0x1082,0xFFFE,0x001D,0x0000,0x7BCF,0xA534,
	0xFFFE,0x0007,0x9CF3,0xA534,0x738E,0xFFFE,0x001F,0x0000,0x9CD3,0xFFFE,0x0006,0x9CF3,0x9D13,0x10A2,0xFFFE,0x0004,0x0000,0x1082,0xA534,0xFFFE,
	0x0014,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0009,0x0000,0x10A2,0xFFFE,0x0005,0x9CF3,0xA514,0x1082,0xFFFE,0x0010,0x0000,0x4A49,0x9CD3,0xFFFE,0x000C,
	0x9CF3,0xAD55,0x6B4D,0xFFFE,0x001E,0x0000,0x2945,0xAD55,0xFFFE,0x0007,0x9CF3,0xA534,0x632C,0xFFFE,0x001F,0x0000,0x94B2,0xFFFE,0x0006,0x9CF3,
	0x9D13,0x10A2,0xFFFE,0x0004,0x0000,0x1082,0xA534,0xFFFE,0x0014,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0009,0x0000,0x10A2,0xFFFE,0x0005,0x9CF3,0x8C51,
	0xFFFE,0x0012,0x0000,0x4A49,0x9CD3,0xFFFE,0x000B,0x9CF3,0xAD55,0x4228,0xFFFE,0x001E,0x0000,0x1062,0xA514,0xFFFE,0x0007,0x9CF3,0xA534,0x632C,
	0xFFFE,0x0007,0x0000,0x1082,0x4228,0xFFFE,0x0006,0x528A,0x39E7,0x2965,0x528A,0x528A,0x39C7,0x3186,0x4A69,0x2124,0xFFFE,0x0008,0x0000,0x94B2,
	0xFFFE,0x0006,0x9CF3,0x9D13,0x10A2,0xFFFE,0x0004,0x0000,0x1082,0xA534,0xFFFE,0x0014,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0006,0x0000,0x1082,0x6B4D,
	0x8C71,0x8C71,0xFFFE,0x0005,0x9CF3,0x8430,0xFFFE,0x0013,0x0000,0x4A49,0x9CD3,0xFFFE,0x000A,0x9CF3,0xAD55,0x4208,0xFFFE,0x001E,0x0000,0x1062,
	0xA514,0xFFFE,0x0004,0x9CF3,0xFFFE,0x0004,0xCE79,0x632C,0xFFFE,0x0006,0x0000,0x39E7,0xB5B6,0xD6BA,0xFFFE,0x0006,0xD69A,0x9CF3,0x7BEF,0xD69A,
	0xD69A,0x94B2,0x8C51,0xD69A,0xD6BA,0x8430,0x0821,0xFFFE,0x0006,0x0000,0xA534,0xFFFE,0x0006,0xCE79,0xB5B6,0x10A2,0xFFFE,0x0004,0x0000,0x1082,
	0xBDD7,0xFFFE,0x0014,0xCE79,0xC658,0x39C7,0xFFFE,0x0005,0x0000,0x1082,0x9CF3,0xDEDB,0xFFFE,0x0007,0xCE79,0x8C71,0xFFFE,0x0014,0x0000,0x4A49,
	0xC618,0xFFFE,0x0009,0xCE79,0xCE59,0x4208,0xFFFE,0x0006,0x0000,0x18A3,0x73AE,0xBDF7,0xFFFE,0x000C,0xC638,0xC618,0x8C71,0x20E4,0xFFFE,0x0006,
	0x0000,0x1062,0xB5B6,0xFFFE,0x0004,0xCE79,0xFFFE,0x0003,0xFFFF,0xF7DE,0x630C,0xFFFE,0x0005,0x0000,0x20E4,0xBDF7,0xFFFE,0x0008,0xFFFF,0xBDF7,
	0x9CD3,0xFFFF,0xFFFF,0xB596,0xA554,0xFFFF,0xFFFF,0xF7BE,0x73AE,0xFFFE,0x0006,0x0000,0xB5D6,0xFFFE,0x0006,0xFFFF,0xCE79,0x1082,0xFFFE,0x0004,
	0x0000,0x1082,0xD69A,0xFFFE,0x0014,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0x632C,0xF79E,0xFFFE,0x0008,0xFFFF,0x9492,0xFFFE,0x0006,0x0000,
	0x4A49,0xC618,0xFFFE,0x0003,0xDEFB,0xD6BA,0x52AA,0xFFFE,0x0008,0x0000,0x7BCF,0xF7BE,0xFFFE,0x0008,0xFFFF,0xEF7D,0x4208,0xFFFE,0x0005,0x0000,
	0x1082,0x9D13,0xF7BE,0xFFFE,0x000F,0xFFFF,0xC618,0x20E4,0xFFFE,0x0005,0x0000,0x1062,0xD69A,0xFFFE,0x0007,0xFFFF,0xF7DE,0x630C,0xFFFE,0x0005,
	0x0000,0x630C,0xF7BE,0xFFFE,0x0008,0xFFFF,0xBDF7,0x9CD3,0xFFFF,0xD6DA,0x528A,0x62EC,0xE73C,0xFFFF,0xFFFF,0xCE59,0x0821,0xFFFE,0x0005,0x0000,
	0xB5D6,0xFFFE,0x0006,0xFFFF,0xCE79,0x0841,0xFFFE,0x0004,0x0000,0x0821,0xD69A,0xFFFE,0x0014,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0xA534,
	0xFFFE,0x0009,0xFFFF,0x9492,0xFFFE,0x0005,0x0000,0x10A2,0xBDF7,0xFFFE,0x0005,0xFFFF,0xEF5D,0x52AA,0xFFFE,0x0008,0x0000,0x7BCF,0xF7BE,0xFFFE,
	0x0007,0xFFFF,0xEF7D,0x4208,0xFFFE,0x0005,0x0000,0x630C,0xF79E,0xFFFE,0x0011,0xFFFF,0x8C71,0xFFFE,0x0005,0x0000,0x1062,0xD69A,0xFFFE,0x0007,
	0xFFFF,0xF7DE,0x630C,0xFFFE,0x0005,0x0000,0x8410,0xFFFE,0x0009,0xFFFF,0xBDF7,0x9CD3,0xFFFF,0x6B4D,0x0000,0x0000,0x9492,0xFFFF,0xFFFF,0xE73C,
	0x2104,0xFFFE,0x0004,0x0020,0x0000,0xB5D6,0xFFFE,0x0006,0xFFFF,0xCE79,0x10A2,0xFFFE,0x0004,0x0000,0x1082,0xDEDB,0xFFFE,0x0014,0xFFFF,0xE75C,
	0x39C7,0xFFFE,0x0005,0x0000,0xAD75,0xFFFE,0x0009,0xFFFF,0x9492,0xFFFE,0x0005,0x0000,0x4208,0xEF7D,0xFFFE,0x0006,0xFFFF,0xEF5D,0x52AA,0xFFFE,
	0x0008,0x0000,0x7BCF,0xF7BE,0xFFFE,0x0006,0xFFFF,0xEF7D,0x4208,0xFFFE,0x0005,0x0000,0x9CD3,0xFFFE,0x0012,0xFFFF,0xCE59,0x0861,0xFFFE,0x0004,
	0x0821,0x1082,0xD69A,0xFFFE,0x0007,0xFFFF,0xF7DE,0x630C,0xFFFE,0x0005,0x0000,0x8410,0xFFFE,0x0009,0xFFFF,0xBDF7,0x9CD3,0xFFFF,0x9492,0x0000,
	0x0000,0xAD75,0xFFFF,0xFFFF,0xE75C,0x2104,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0006,0xFFFF,0xCE79,0x10A2,0xFFFE,0x0004,0x0000,0x1082,0xDEDB,
	0xFFFE,0x0014,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0xAD75,0xFFFE,0x0009,0xFFFF,0x9492,0xFFFE,0x0005,0x0000,0x4A69,0xF7BE,0xFFFE,0x0007,
	0xFFFF,0xEF5D,0x52AA,0xFFFE,0x0008,0x0000,0x7BCF,0xF7BE,0xFFFE,0x0005,0xFFFF,0xEF7D,0x4208,0xFFFE,0x0005,0x0000,0xA514,0xFFFE,0x0013,0xFFFF,
	0xFFFE,0x0006,0xF7DE,0xFFFE,0x0008,0xFFFF,0xF7DE,0x630C,0xFFFE,0x0005,0x0000,0x8410,0xFFFE,0x0005,0xFFFF,0xF7BE,0xFFFE,0x0003,0xFFFF,0xBDF7,
	0x9CD3,0xFFFF,0xF7BE,0x8C51,0x8C71,0xF7DE,0xFFFF,0xFFFF,0xE75C,0x2104,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0006,0xFFFF,0xCE79,0x10A2,0xFFFE,
	0x0004,0x0000,0x1082,0xD6BA,0xFFFE,0x0014,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0xAD75,0xFFFE,0x0009,0xFFFF,0x9492,0xFFFE,0x0005,0x0000,
	0x4A69,0xF7BE,0xFFFE,0x0008,0xFFFF,0xEF5D,0x52AA,0xFFFE,0x0008,0x0000,0x8C51,0xFFFE,0x0005,0xFFFF,0xEF7D,0x4208,0xFFFE,0x0005,0x0000,0x9D13,
	0xFFFE,0x0011,0xF7DE,0xFFFE,0x0010,0xFFFF,0xF7DE,0x630C,0xFFFE,0x0005,0x0000,0x8410,0xFFFE,0x0005,0xFFFF,0x6B4D,0xDEFB,0xFFFF,0xFFFF,0xBDF7,
	0x9CD3,0xFFFF,0xFFFF,0xB596,0xA534,0xFFFE,0x0003,0xFFFF,0xE75C,0x2104,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0006,0xFFFF,0xCE79,0x10A2,0xFFFE,
	0x0004,0x0000,0x1082,0xD69A,0xFFFE,0x0014,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0xAD75,0xFFFE,0x0009,0xFFFF,0x9492,0xFFFE,0x0005,0x0000,
	0x4A69,0xF7BE,0xFFFE,0x0009,0xFFFF,0xEF5D,0x52AA,0xFFFE,0x0007,0x0000,0x632C,0xFFDF,0xFFFE,0x0004,0xFFFF,0xEF7D,0x4208,0xFFFE,0x0005,0x0000,
	0x3186,0x630C,0xFFFE,0x0012,0x632C,0xFFFE,0x0006,0x630C,0xD6BA,0xFFFE,0x0007,0xFFFF,0xF7DE,0x630C,0xFFFE,0x0005,0x0000,0x8410,0xFFFE,0x0005,
	0xFFFF,0x630C,0xDEDB,0xFFFF,0xFFFF,0xBDF7,0x52AA,0x9492,0x9492,0x632C,0xA534,0xFFFE,0x0003,0xFFFF,0xE75C,0x2104,0xFFFE,0x0005,0x0000,0xB5D6,
	0xFFFE,0x0006,0xFFFF,0xCE79,0x10A2,0xFFFE,0x0004,0x0000,0x1082,0xD69A,0xFFFE,0x0014,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0xAD75,0xFFFE,
	0x0009,0xFFFF,0x9492,0xFFFE,0x0005,0x0000,0x4A69,0xF7BE,0xFFFE,0x000A,0xFFFF,0xEF5D,0x52AA,0xFFFE,0x0006,0x0000,0x632C,0xFFDF,0xFFFE,0x0004,
	0xFFFF,0xEF7D,0x4208,0xFFFE,0x001E,0x0000,0x1062,0xD69A,0xFFFE,0x0007,0xFFFF,0xF7DE,0x630C,0xFFFE,0x0005,0x0000,0x8410,0xFFFF,0xCE59,0x8430,
	0xBDD7,0xFFFF,0x630C,0xDEDB,0xFFFF,0xFFFF,0xBDF7,0x73AE,0xFFFE,0x0003,0xC638,0xE73C,0xFFFE,0x0003,0xFFFF,0xE75C,0x2104,0xFFFE,0x0005,0x0000,
	0xB5D6,0xFFFE,0x0006,0xFFFF,0xCE79,0x10A2,0xFFFE,0x0004,0x0000,0x1082,0xD69A,0xFFFE,0x0014,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0xAD75,
	0xFFFE,0x0009,0xFFFF,0x9492,0xFFFE,0x0005,0x0000,0x4A69,0xF7BE,0xFFFE,0x000B,0xFFFF,0xEF5D,0x4A49,0xFFFE,0x0005,0x0000,0x632C,0xFFDF,0xFFFE,
	0x0004,0xFFFF,0xEF7D,0x4208,0xFFFE,0x001E,0x0000,0x1062,0xD69A,0xFFFE,0x0007,0xFFFF,0xF7DE,0x630C,0xFFFE,0x0005,0x0000,0x8410,0xE75C,0x18C3,
	0x0000,0x0020,0x9492,0x39E7,0xDEDB,0xFFFF,0xFFFF,0xBDF7,0x9CD3,0xFFFE,0x0007,0xFFFF,0xE75C,0x2104,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0006,
	0xFFFF,0xCE79,0x10A2,0xFFFE,0x0004,0x0000,0x1082,0xD69A,0xFFFE,0x0014,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0xAD75,0xFFFE,0x0009,0xFFFF,
	0x9492,0xFFFE,0x0005,0x0000,0x4A69,0xF7BE,0xFFFE,0x000C,0xFFFF,0x7BEF,0xFFFE,0x0005,0x0000,0x632C,0xFFDF,0xFFFE,0x0004,0xFFFF,0xEF7D,0x4208,
	0xFFFE,0x001E,0x0000,0x1062,0xD69A,0xFFFE,0x0007,0xFFFF,0xF7DE,0x630C,0xFFFE,0x0005,0x0000,0x8410,0xE73C,0x0841,0x0000,0x0000,0x9CF3,0x4228,
	0xDEDB,0xFFFF,0xFFFF,0xBDF7,0x9CD3,0xFFFE,0x0007,0xFFFF,0xE75C,0x2104,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0006,0xFFFF,0xCE79,0x10A2,0xFFFE,
	0x0004,0x0000,0x1082,0xD69A,0xFFFE,0x0014,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0xAD75,0xFFFE,0x0009,0xFFFF,0x9492,0xFFFE,0x0005,0x0000,
	0x4A69,0xF7BE,0xFFFE,0x000C,0xFFFF,0x7BEF,0xFFFE,0x0005,0x0000,0x632C,0xFFDF,0xFFFE,0x0004,0xFFFF,0xEF7D,0x4208,0xFFFE,0x001E,0x0000,0x1062,
	0xD69A,0xFFFE,0x0007,0xFFFF,0xF7DE,0x630C,0xFFFE,0x0005,0x0000,0x8410,0xFFFF,0xBDD7,0x62EC,0xA534,0xFFDF,0x630C,0xDEDB,0xFFFF,0xFFFF,0xBDF7,
	0x6B4D,0xFFFE,0x0003,0xB596,0xC658,0xFFFE,0x0003,0xFFFF,0xE73C,0x2104,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0006,0xFFFF,0xCE79,0x10A2,0xFFFE,
	0x0004,0x0000,0x1082,0xD69A,0xFFFE,0x0014,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0xAD75,0xFFFE,0x0009,0xFFFF,0x9492,0xFFFE,0x0005,0x0000,
	0x4A69,0xF7BE,0xFFFE,0x000C,0xFFFF,0x7BEF,0xFFFE,0x0005,0x0000,0x632C,0xFFDF,0xFFFE,0x0004,0xFFFF,0xEF7D,0x39C7,0xFFFE,0x001E,0x0000,0x1062,
	0xD69A,0xFFFE,0x0007,0xFFFF,0xF7DE,0x630C,0xFFFE,0x0005,0x0000,0x8410,0xFFFE,0x0005,0xFFFF,0x630C,0xDEDB,0xFFFF,0xFFFF,0xBDF7,0x632C,0xAD55,
	0xAD55,0x8C71,0x6B6D,0xFFFE,0x0003,0xFFFF,0xE71C,0x2104,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0006,0xFFFF,0xCE79,0x10A2,0xFFFE,0x0004,0x0000,
	0x1082,0xD69A,0xFFFE,0x0014,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0xB5B6,0xFFFE,0x0009,0xFFFF,0x9492,0xFFFE,0x0005,0x0000,0x4A69,0xF7BE,
	0xFFFE,0x000C,0xFFFF,0x7BEF,0xFFFE,0x0005,0x0000,0x632C,0xFFDF,0xFFFE,0x0004,0xFFFF,0xEF7D,0x39C7,0xFFFE,0x0005,0x0000,0x6B2D,0xFFFE,0x0007,
	0x94D2,0x94B2,0xFFFE,0x0003,0x94D2,0x94B2,0xFFFE,0x0006,0x94D2,0x8410,0x0841,0xFFFE,0x0004,0x0000,0x1062,0xD69A,0xFFFE,0x0004,0xFFFF,0xFFFE,
	0x0004,0xC618,0x630C,0xFFFE,0x0005,0x0000,0x8410,0xFFFE,0x0005,0xC618,0x4A49,0xA534,0xC618,0xC618,0x9492,0x73AE,0xC618,0xC618,0xA534,0x528A,
	0xFFFE,0x0003,0xC618,0xBDD7,0x2104,0xFFFE,0x0005,0x0000,0xA514,0xFFFE,0x0006,0xC618,0xAD75,0x0841,0xFFFE,0x0004,0x0000,0x0821,0xB596,0xFFFE,
	0x0014,0xC618,0xBDF7,0x39C7,0xFFFE,0x0005,0x0000,0x9CF3,0xFFFE,0x0009,0xC618,0x8C51,0xFFFE,0x0005,0x0000,0x4A69,0xC638,0xFFFE,0x000C,0xC618,
	0x7BCF,0xFFFE,0x0005,0x0000,0x6B2D,0xC638,0xFFFE,0x0005,0xC618,0x4208,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0012,0xC618,0xB596,0x0861,0xFFFE,
	0x0004,0x0000,0x1062,0xB596,0xFFFE,0x0004,0xC618,0xFFFE,0x0003,0x9CF3,0xA534,0x62EC,0xFFFE,0x0005,0x0000,0x7BEF,0xA514,0xFFFE,0x0004,0x9CF3,
	0x8410,0x9CD3,0x9CF3,0x9CF3,0x73AE,0x5AEB,0x9CF3,0x9CF3,0x5AEB,0x3186,0x94B2,0x9CF3,0x9CF3,0xA514,0x2104,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,
	0x0007,0x9CF3,0x0841,0xFFFE,0x0004,0x0000,0x0821,0xA534,0xFFFE,0x0014,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0009,0x9CF3,
	0x8430,0xFFFE,0x0005,0x0000,0x4A69,0xAD75,0xFFFE,0x000B,0x9CF3,0x9D13,0x7BCF,0xFFFE,0x0005,0x0000,0x6B2D,0xAD55,0xFFFE,0x0004,0x9CF3,0xAD55,
	0x39C7,0xFFFE,0x0005,0x0000,0x9492,0xFFFE,0x0003,0x9CF3,0x8410,0x5ACB,0x9492,0xFFFE,0x0006,0x9CF3,0x8410,0x5ACB,0x9492,0xFFFE,0x0003,0x9CF3,
	0x9CD3,0x0861,0xFFFE,0x0004,0x0000,0x1062,0xA514,0xFFFE,0x0007,0x9CF3,0xA534,0x62EC,0xFFFE,0x0005,0x0000,0x7BEF,0xA514,0xFFFE,0x0008,0x9CF3,
	0x73AE,0x5AEB,0x9CF3,0x738E,0x0000,0x0000,0x39E7,0x9CF3,0x9CF3,0xA534,0x2104,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0007,0x9CF3,0x0841,0xFFFE,
	0x0004,0x0000,0x0821,0xA514,0xFFFE,0x0014,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0009,0x9CF3,0x8430,0xFFFE,0x0005,0x0000,
	0x4A69,0xAD75,0xFFFE,0x000B,0x9CF3,0x9D13,0x7BCF,0xFFFE,0x0005,0x0000,0x6B2D,0xAD55,0xFFFE,0x0004,0x9CF3,0xAD55,0x39C7,0x0000,0xFFFE,0x0004,
	0x0020,0x39C7,0x4208,0x4208,0x39C7,0x0000,0x0020,0x1082,0xFFFE,0x0005,0x4208,0x39E7,0x0000,0x0020,0x1062,0xFFFE,0x0003,0x4208,0x41E8,0xFFFE,
	0x0005,0x0020,0x1062,0xA514,0xFFFE,0x0007,0x9CF3,0xA534,0x62EC,0xFFFE,0x0005,0x0000,0x630C,0xA554,0xFFFE,0x0008,0x9CF3,0x73AE,0x5AEB,0x9CF3,
	0x8410,0x0000,0x0000,0x630C,0xFFFE,0x0003,0x9CF3,0x0861,0xFFFE,0x0003,0x0000,0x0020,0x0000,0x94B2,0xFFFE,0x0007,0x9CF3,0x0841,0xFFFE,0x0005,
	0x0000,0x9492,0xFFFE,0x0014,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0009,0x9CF3,0x8430,0xFFFE,0x0005,0x0000,0x4A69,0xAD75,
	0xFFFE,0x000B,0x9CF3,0x9D13,0x7BCF,0xFFFE,0x0005,0x0000,0x6B2D,0xAD55,0xFFFE,0x0004,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0005,0x0000,0x6B6D,0x8430,
	0x8430,0x7BEF,0x18A3,0x0000,0x4A69,0x8C51,0xFFFE,0x0004,0x8430,0x7BEF,0x18C3,0x0000,0x4A49,0x8C51,0xFFFE,0x0003,0x8430,0x0841,0xFFFE,0x0004,
	0x0020,0x1062,0xA514,0xFFFE,0x0007,0x9CF3,0xA534,0x62EC,0xFFFE,0x0005,0x0000,0x18E3,0xA534,0xFFFE,0x0008,0x9CF3,0x73AE,0x5AEB,0x9CF3,0xA514,
	0x7BCF,0x4208,0x9CF3,0x9CF3,0xA514,0x7BCF,0xFFFE,0x0006,0x0000,0x94B2,0xFFFE,0x0007,0x9CF3,0x0841,0xFFFE,0x0005,0x0000,0x528A,0xAD55,0xFFFE,
	0x0013,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0009,0x9CF3,0x8430,0xFFFE,0x0005,0x0000,0x4A69,0xAD75,0xFFFE,0x000B,0x9CF3,
	0x9D13,0x7BCF,0xFFFE,0x0005,0x0000,0x6B2D,0xAD55,0xFFFE,0x0004,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0005,0x0000,0x5AEB,0xAD55,0x9CF3,0x9CF3,0x9CD3,
	0x7BEF,0xFFFE,0x0007,0x9CF3,0x9CD3,0x7BEF,0xFFFE,0x0003,0x9CF3,0xA514,0x8410,0xFFFE,0x0004,0x0000,0x0020,0x1062,0xA514,0xFFFE,0x0007,0x9CF3,
	0xA534,0x62EC,0xFFFE,0x0006,0x0000,0x4A69,0xA534,0xAD55,0xFFFE,0x0006,0x9CF3,0x73AE,0x5AEB,0x9CF3,0x9CF3,0x8430,0x4208,0x9D13,0xAD55,0x8C51,
	0x1082,0xFFFE,0x0006,0x0000,0x94B2,0xFFFE,0x0007,0x9CF3,0x0841,0xFFFE,0x0006,0x0000,0x630C,0xA534,0xAD55,0xFFFE,0x000C,0xA534,0xA514,0xFFFE,
	0x0004,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0009,0x9CF3,0x8430,0xFFFE,0x0005,0x0000,0x4A69,0xAD75,0xFFFE,0x000B,0x9CF3,
	0x9D13,0x7BCF,0xFFFE,0x0005,0x0000,0x6B2D,0xAD55,0xFFFE,0x0004,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0005,0x0000,0x0861,0x9492,0xA534,0xFFFE,0x000E,
	0x9CF3,0x9D13,0x9CF3,0x2965,0xFFFE,0x0005,0x0000,0x1062,0xA514,0xFFFE,0x0007,0x9CF3,0xA534,0x62EC,0xFFFE,0x0007,0x0000,0x2104,0x632C,0xFFFE,
	0x0006,0x738E,0x52AA,0x4208,0x6B6D,0x738E,0x630C,0x2965,0x738E,0x4A69,0x0020,0xFFFE,0x0007,0x0000,0x94B2,0xFFFE,0x0007,0x9CF3,0x0841,0xFFFE,
	0x0007,0x0000,0x18C3,0x4208,0xFFFE,0x000C,0x4228,0x8C51,0xFFFE,0x0004,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0005,0x0000,0x8410,0xFFFE,0x0009,0x9CF3,
	0x8430,0xFFFE,0x0005,0x0000,0x4A69,0xAD75,0xFFFE,0x000B,0x9CF3,0x9D13,0x7BCF,0xFFFE,0x0005,0x0000,0x6B2D,0xAD55,0xFFFE,0x0004,0x9CF3,0xAD55,
	0x39C7,0xFFFE,0x0006,0x0000,0x18C3,0x7BEF,0x9CF3,0xFFFE,0x000C,0x9CD3,0x9CF3,0x8C51,0x3186,0xFFFE,0x0006,0x0000,0x1062,0xA514,0xFFFE,0x0007,
	0x9CF3,0xA534,0x62EC,0xFFFE,0x001F,0x0000,0x94B2,0xFFFE,0x0007,0x9CF3,0x0841,0xFFFE,0x0015,0x0000,0x8430,0xFFFE,0x0004,0x9CF3,0xAD55,0x39C7,
	0xFFFE,0x0005,0x0000,0x9492,0xFFFE,0x0009,0x9CF3,0x8430,0xFFFE,0x0005,0x0000,0x4A69,0xAD75,0xFFFE,0x000B,0x9CF3,0x9D13,0x7BCF,0xFFFE,0x0005,
	0x0000,0x6B2D,0xAD55,0xFFFE,0x0004,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0008,0x0000,0x0020,0xFFFE,0x000C,0x0841,0x0020,0xFFFE,0x0008,0x0000,0x1062,
	0xA514,0xFFFE,0x0007,0x9CF3,0xA534,0x632C,0xFFFE,0x001F,0x0000,0x94B2,0xFFFE,0x0006,0x9CF3,0xA534,0x18C3,0xFFFE,0x0015,0x0000,0x8430,0xFFFE,
	0x0004,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0009,0x9CF3,0x8430,0xFFFE,0x0005,0x0000,0x4A69,0xAD75,0xFFFE,0x000B,0x9CF3,
	0x9D13,0x7BCF,0xFFFE,0x0005,0x0000,0x6B2D,0xAD55,0xFFFE,0x0004,0x9CF3,0xAD55,0x39C7,0xFFFE,0x001E,0x0000,0x1062,0xA514,0xFFFE,0x0007,0x9CF3,
	0x9D13,0x8C71,0xFFFE,0x001F,0x0000,0x94B2,0xFFFE,0x0006,0x9CF3,0xAD55,0x5ACB,0xFFFE,0x0015,0x0000,0x8430,0xFFFE,0x0004,0x9CF3,0xAD55,0x39C7,
	0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0009,0x9CF3,0x8430,0xFFFE,0x0005,0x0000,0x4A69,0xAD75,0xFFFE,0x000B,0x9CF3,0x9D13,0x7BCF,0xFFFE,0x0005,
	0x0000,0x62EC,0xA514,0xFFFE,0x0004,0x9CF3,0xAD55,0x5AEB,0xFFFE,0x001E,0x0000,0x2104,0xA554,0xFFFE,0x0008,0x9CF3,0xAD55,0x4208,0xFFFE,0x001E,
	0x0000,0x94B2,0xFFFE,0x0008,0x9CF3,0x2124,0xFFFE,0x0014,0x0000,0x8430,0xFFFE,0x0004,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,
	0x0009,0x9CF3,0x8430,0xFFFE,0x0005,0x0000,0x4A69,0xAD75,0xFFFE,0x000B,0x9CF3,0x9D13,0x7BCF,0xFFFE,0x0005,0x0000,0x5AEB,0xFFFE,0x0005,0x9CF3,
	0x9D13,0x9492,0x0020,0xFFFE,0x001D,0x0000,0x6B6D,0xA534,0xFFFE,0x0008,0x9CF3,0x9D13,0xA534,0x4208,0xFFFE,0x001D,0x0000,0x94B2,0xFFFE,0x0007,
	0x9CF3,0xA514,0x9CD3,0x39C7,0xFFFE,0x0013,0x0000,0x8430,0xFFFE,0x0004,0x9CF3,0xAD55,0x39C7,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0009,0x9CF3,
	0x8430,0xFFFE,0x0005,0x0000,0x4A69,0xAD75,0xFFFE,0x000B,0x9CF3,0x9D13,0x7BCF,0xFFFE,0x0005,0x0000,0x630C,0xA534,0xFFFE,0x0005,0x9CF3,0xA554,
	0x738E,0xFFFE,0x001C,0x0000,0x4A29,0xA514,0xFFFE,0x0005,0x9CF3,0xFFFE,0x0005,0x9D13,0xA514,0xAD55,0x9492,0x630C,0xFFFE,0x0014,0x5AEB,0x528A,
	0xFFFE,0x0006,0x0000,0x94B2,0xFFFE,0x0008,0x9D13,0xA514,0xAD55,0x94D2,0xFFFE,0x0012,0x9492,0x9CD3,0xFFFE,0x0004,0x9D13,0xAD55,0x39E7,0xFFFE,
	0x0005,0x10A2,0x94D2,0xFFFE,0x0009,0x9D13,0x8C71,0xFFFE,0x0005,0x4A69,0x6B2D,0xAD75,0xFFFE,0x000B,0x9D13,0xA514,0x8430,0xFFFE,0x0005,0x4A69,
	0x73AE,0xAD55,0xFFFE,0x0006,0x9D13,0xAD55,0x8430,0x3186,0xFFFE,0x0018,0x0841,0x18A3,0x6B4D,0xA514,0xFFFE,0x0006,0x9D13,0xFFFE,0x0008,0xFFFF,
	0xFFFE,0x0012,0xF7DE,0xFFFE,0x0003,0xFFFF,0xC638,0xFFFE,0x0006,0x0000,0xB5D6,0xFFFE,0x0023,0xFFFF,0xFFFE,0x0006,0xFFDF,0xFFFE,0x002D,0xFFFF,
	0xFFDF,0xE73C,0xCE59,0xFFFE,0x0017,0xC658,0xD6DA,0xF7DE,0xFFFE,0x0024,0xFFFF,0xC658,0xFFFE,0x0006,0x0000,0xB5D6,0xFFFE,0x0096,0xFFFF,0xC658,
	0xFFFE,0x0006,0x0000,0xB5D6,0xFFFE,0x0096,0xFFFF,0xC658,0xFFFE,0x0006,0x0000,0xB5D6,0xFFFE,0x0096,0xFFFF,0xC658,0xFFFE,0x0006,0x0000,0xB5D6,
	0xFFFE,0x0023,0xFFFF,0xF79E,0xFFFE,0x0005,0xEF9D,0xF7BE,0xFFFE,0x006C,0xFFFF,0xCE59,0x0821,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0022,0xFFFF,
	0xE75C,0x31A6,0xFFFE,0x0005,0x0000,0xAD75,0xFFFE,0x006C,0xFFFF,0xCE59,0x0821,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0022,0xFFFF,0xE75C,0x39C7,
	0xFFFE,0x0005,0x0000,0xAD75,0xFFFE,0x006C,0xFFFF,0xC658,0x0821,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0022,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,
	0x0000,0xAD75,0xFFFE,0x006C,0xFFFF,0xC638,0x0821,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0022,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0xAD75,
	0xFFFE,0x006C,0xFFFF,0xC638,0x0821,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0022,0xFFFF,0xE75C,0x39C7,0xFFFE,0x0005,0x0000,0xAD75,0xFFFE,0x006C,
	0xFFFF,0xCE59,0x0821,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0022,0xFFFF,0xE75C,0x3186,0xFFFE,0x0005,0x0000,0xAD75,0xFFFE,0x006C,0xFFFF,0xCE59,
	0x0821,0xFFFE,0x0005,0x0000,0xB5D6,0xFFFE,0x0023,0xFFFF,0xEF9D,0xFFFE,0x0005,0xEF7D,0xF7BE,0xFFFE,0x004F,0xFFFF,0xFFFE,0x001D,0xD6BA,0xB596,
	0x0821,0xFFFE,0x0005,0x0000,0xAD55,0xFFFE,0x0079,0xD6BA,0xFFFE,0x001D,0x9CF3,0x9CD3,0x0821,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0096,0x9CF3,
	0x9CD3,0x0821,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0096,0x9CF3,0x9CD3,0x0821,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0096,0x9CF3,0x9CD3,0x0821,
	0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0096,0x9CF3,0x9CD3,0x0821,0xFFFE,0x0005,0x0000,0x94B2,0xFFFE,0x0096,0x9CF3,0x9CD3,0x0821,0xFFFE,0x0005,
	0x0000,0x94B2,0xFFFE,0x0096,0x9CF3,0x9CD3,0x3166,0xFFFE,0x0005,0x2965,0x94B2,0xFFFE,0x0252,0x9CF3,
};//img_data


void SCREENS_dialog_clear(){
	
	// clear the structure used to store the current parameters edition screen
	screens_dialog.ev_process_cur_function = NULL;
	screens_dialog.load_cur_function = NULL;
	screens_dialog.show_cur_function = NULL;
	screens_dialog.i8_state = SCREEN_DIALOG_INITIAL_STATE;	
		
}//SCREENS_dialog_clear



void SCREENS_dialog_init(){
	
	SCREENS_dialog_clear();
	
}//void SCREENS_dialog_init(){



int8_t SCREENS_dialog_load(int16_t i16_received_dialog_id,int16_t i16_dialog_state){
	int i8_ret_val = 1;

	switch (i16_received_dialog_id){

		case SCREEN_DIALOG_ID_INTRO:
			SCREENS_dialog_clear();
			screens_dialog.load_cur_function = SCREENS_dialog_load_INTRO;
			screens_dialog.show_cur_function = SCREENS_dialog_show_INTRO;
			screens_dialog.ev_process_cur_function = SCREENS_dialog_ev_manager_INTRO;
			break;

		case SCREEN_DIALOG_ID_LOAD_RUN_ROM_FILE:
			SCREENS_dialog_clear();
			screens_dialog.load_cur_function = SCREENS_dialog_load_LOAD_RUN_ROM_FILE;
			screens_dialog.show_cur_function = SCREENS_dialog_show_LOAD_RUN_ROM_FILE;
			screens_dialog.ev_process_cur_function = SCREENS_dialog_ev_manager_LOAD_RUN_ROM_FILE;
			break;
		
		case SCREEN_DIALOG_ID_LOAD_ROM_FILE:
		    SCREENS_dialog_clear();
			screens_dialog.load_cur_function = SCREENS_dialog_load_LOAD_ROM_FILE;
			screens_dialog.show_cur_function = SCREENS_dialog_show_LOAD_ROM_FILE;
			screens_dialog.ev_process_cur_function = SCREENS_dialog_ev_manager_LOAD_ROM_FILE;
			break;

		case SCREEN_DIALOG_ID_RUN_RAM:
			SCREENS_dialog_clear();
			screens_dialog.load_cur_function = SCREENS_dialog_load_RUN_RAM;
			screens_dialog.show_cur_function = SCREENS_dialog_show_RUN_RAM;
			screens_dialog.ev_process_cur_function = SCREENS_dialog_ev_manager_RUN_RAM;
			break;
			
		case SCREEN_DIALOG_ID_SHOW_RAM_INFO:
			SCREENS_dialog_clear();
			screens_dialog.load_cur_function = SCREENS_dialog_load_SHOW_RAM_INFO;
			screens_dialog.show_cur_function = SCREENS_dialog_show_SHOW_RAM_INFO;
			screens_dialog.ev_process_cur_function = SCREENS_dialog_ev_manager_SHOW_RAM_INFO;
			break;

		case SCREEN_DIALOG_ID_DUMP_ROM:
			SCREENS_dialog_clear();
			screens_dialog.load_cur_function = SCREENS_dialog_load_DUMP_ROM;
			screens_dialog.show_cur_function = SCREENS_dialog_show_DUMP_ROM;
			screens_dialog.ev_process_cur_function = SCREENS_dialog_ev_manager_DUMP_ROM;
			break;
			
         case SCREEN_DIALOG_ID_SAVE_RAM_AS_FILE:
			SCREENS_dialog_clear();
			screens_dialog.load_cur_function = SCREENS_dialog_load_SAVE_RAM_AS_FILE;
			screens_dialog.show_cur_function = SCREENS_dialog_show_SAVE_RAM_AS_FILE;
			screens_dialog.ev_process_cur_function = SCREENS_dialog_ev_manager_SAVE_RAM_AS_FILE;
			break;

         case SCREEN_DIALOG_ID_SAVE_RAM_FILE:
			 SCREENS_dialog_clear();
			 screens_dialog.load_cur_function = SCREENS_dialog_load_SAVE_RAM_FILE;
			 screens_dialog.show_cur_function = SCREENS_dialog_show_SAVE_RAM_FILE;
			 screens_dialog.ev_process_cur_function = SCREENS_dialog_ev_manager_SAVE_RAM_FILE;
			 break;
			 
         case SCREEN_DIALOG_ID_RECEIVE_RUN_RAM:
			 SCREENS_dialog_clear();
			 screens_dialog.load_cur_function = SCREENS_dialog_load_RECEIVE_RUN_RAM;
			 screens_dialog.show_cur_function = SCREENS_dialog_show_RECEIVE_RUN_RAM;
			 screens_dialog.ev_process_cur_function = SCREENS_dialog_ev_manager_RECEIVE_RUN_RAM;		 
			 break;

         case SCREEN_DIALOG_ID_RECEIVE_RAM:
			 SCREENS_dialog_clear();
			 screens_dialog.load_cur_function = SCREENS_dialog_load_RECEIVE_RAM;
			 screens_dialog.show_cur_function = SCREENS_dialog_show_RECEIVE_RAM;
			 screens_dialog.ev_process_cur_function = SCREENS_dialog_ev_manager_RECEIVE_RAM;
			 break;

         case SCREEN_DIALOG_ID_SEND_RAM:
			 SCREENS_dialog_clear();
			 screens_dialog.load_cur_function = SCREENS_dialog_load_SEND_RAM;
			 screens_dialog.show_cur_function = SCREENS_dialog_show_SEND_RAM;
			 screens_dialog.ev_process_cur_function = SCREENS_dialog_ev_manager_SEND_RAM;
			 break;

         case SCREEN_DIALOG_ID_TEST:
			 SCREENS_dialog_clear();
			 screens_dialog.load_cur_function = SCREENS_dialog_load_TEST;
			 screens_dialog.show_cur_function = SCREENS_dialog_show_TEST;
			 screens_dialog.ev_process_cur_function = SCREENS_dialog_ev_manager_TEST;
			 break;
					
		default:
			i8_ret_val = -1;
			break;
	
	}//switch

	// call to the function that loads current dialog screen data
	if (i8_ret_val>=0){
		
		// update screens_dialog.i8_state before calling current dialog specific load function
		screens_dialog.i8_state = (int8_t) i16_dialog_state;
		if (screens_dialog.load_cur_function!=NULL){
			i8_ret_val = screens_dialog.load_cur_function();
		}//if
			
		// set the SCREENS control in DIALOG SCREEN mode
		screens_control.i8_current_type=SCREENS_DIALOG_SCREEN;		
		screens_control.i16_current_ID=i16_received_dialog_id;	
		// set the OnLoad event to show in screen the new loaded dialog
		screens_control.ui8_on_load_event = TRUE;
				
	}//if

	return i8_ret_val;

}//SCREENS_dialog_load



void SCREENS_dialog_show(){


	// call to the function that shows current dialog screen specific data
	if (screens_dialog.show_cur_function!=NULL){
		screens_dialog.show_cur_function(SCREEN_EMPTY_MESSAGE);
	}//if
	
}//SCREENS_dialog_show



void SCREENS_dialog_ev_manager(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	
	
	// call to the function that processes the KEYS pressed by the user in the current dialog screen	
	if (screens_dialog.ev_process_cur_function!=NULL){
		screens_dialog.ev_process_cur_function(pi16_encoders_var_value, pui8_pushbutton_values);
	}//if

}//SCREENS_dialog_ev_manager



int8_t SCREENS_dialog_load_LOAD_ROM_FILE(){
	int8_t i8_ret_val = 1;


	// update the current dialog screen
	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:	
		case SCREEN_DIALOG_LOAD_ROM_FILE_MOUNTING:		
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_FAST_MESSAGE_TIMEOUT);			  
			break;
			
		case SCREEN_DIALOG_LOAD_ROM_FILE_LOADING_FILE:
			break;
			
		case SCREEN_DIALOG_LOAD_ROM_FILE_LOADED:			
		case SCREEN_DIALOG_LOAD_ROM_FILE_ACCESS_ERROR:	
		case SCREEN_DIALOG_LOAD_ROM_FILE_FORMAT_VER_ERROR:
		case SCREEN_DIALOG_LOAD_ROM_FILE_CANCELLED:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);		
			break;
			
		default:
			i8_ret_val = -1;
			break;
						
	}//switch

	return i8_ret_val;

}//SCREENS_dialog_load_LOAD_ROM_FILE



int8_t SCREENS_dialog_show_LOAD_ROM_FILE(uint8_t * ui8_message){
	int8_t i8_ret_val = 1;
	

	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_LOAD_ROM_FILE_MOUNTING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer		
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Mounting SD card   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 			
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"    unit. Wait ...    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 			
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
		
		case SCREEN_DIALOG_LOAD_ROM_FILE_LOADING_FILE:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  Loading  selected   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  ROM file. Wait...   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();			
			break;
			
		case SCREEN_DIALOG_LOAD_ROM_FILE_LOADED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  Selected ROM file   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   has been loaded    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"      to RAM.         ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;

		case SCREEN_DIALOG_LOAD_ROM_FILE_ACCESS_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   SD card unit or    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"     file access      ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"       error.         ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;

		case SCREEN_DIALOG_LOAD_ROM_FILE_FORMAT_VER_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"    Error opening    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  selected ROM file. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();			
			break;
			
		case SCREEN_DIALOG_LOAD_ROM_FILE_CANCELLED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"    Load ROM file     ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"      cancelled.      ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
							
		default:
			i8_ret_val = -1;
			break;
				
	}//switch

	return i8_ret_val;
	
}//SCREENS_dialog_show_LOAD_ROM_FILE



int8_t SCREENS_dialog_ev_manager_LOAD_ROM_FILE(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	int8_t i8_ret_val = 1;	
	int16_t i16_aux=0;	


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_LOAD_ROM_FILE_MOUNTING:	
				
			// in the on load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
				
				// print in screen the title of the new loaded menu
				SCREENS_print_title("Load ROM file to RAM",0);				
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait...",0);
				SCREENS_print_help("",1);				
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
					
			}//if		
		
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				 
				 i16_aux=FILE_SYS_mount("", 1);
				 if (i16_aux<0){
					
					// load dialog that shows unit mount error
				 	SCREENS_dialog_load(SCREEN_DIALOG_ID_LOAD_ROM_FILE,SCREEN_DIALOG_LOAD_ROM_FILE_ACCESS_ERROR);						
				 
				 }else{

					i16_aux = FILE_SYS_dir_open("");
					if (i16_aux<0){
						
						// load dialog that shows the open directory error 
						SCREENS_dialog_load(SCREEN_DIALOG_ID_LOAD_ROM_FILE,SCREEN_DIALOG_LOAD_ROM_FILE_ACCESS_ERROR);
					
					}else{
						
						// load the file explorer screen
						SCREENS_f_explorer_load(SCREEN_F_EXPLORER_LOAD_ROM_FILE, SCREEN_F_EXPLORER_INITIAL_STATE);
						
					}//if				 

				 }//if
					
			}//if
			break;
	
		case SCREEN_DIALOG_LOAD_ROM_FILE_LOADING_FILE:
		
			// in the onload event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
			
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Load ROM file to RAM",0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait...",0);
				SCREENS_print_help("",1);			
			
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			
			}//if
			break;

		case SCREEN_DIALOG_LOAD_ROM_FILE_LOADED:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
		
				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )			
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Load ROM file to RAM",0);		
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
			    SCREENS_dialog_show();
			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
				
			}//if
			break;
		
		case SCREEN_DIALOG_LOAD_ROM_FILE_ACCESS_ERROR:
		case SCREEN_DIALOG_LOAD_ROM_FILE_FORMAT_VER_ERROR:
		case SCREEN_DIALOG_LOAD_ROM_FILE_CANCELLED:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
				
				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )				
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Load ROM file to RAM",0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);		
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
				
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
				
			}//if						
			break;
			
		default:
			i8_ret_val = -1;
			break;
		
	}//switch
	
	return i8_ret_val;	
	
	
}//SCREENS_dialog_ev_manager_LOAD_ROM_FILE



int8_t SCREENS_dialog_load_LOAD_RUN_ROM_FILE(){
	int8_t i8_ret_val = 1;


	// update the current dialog screen
	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:	
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_MOUNTING:		
	    case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_RUNNING_FILE:		
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_FAST_MESSAGE_TIMEOUT);		
			break;
			
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_LOADED:
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_ACCESS_ERROR:
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_FORMAT_VER_ERROR:
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_CANCELLED:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);
			break;
				
		default:
			i8_ret_val = -1;
			break;
						
	}//switch

	return i8_ret_val;

}//SCREENS_dialog_load_LOAD_RUN_ROM_FILE



int8_t SCREENS_dialog_show_LOAD_RUN_ROM_FILE(uint8_t * ui8_message){
	int8_t i8_ret_val = 1;


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_MOUNTING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer		
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Mounting SD card   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"    unit. Wait ...    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
				
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_RUNNING_FILE:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);		
			// call the function that shows in the LCD the number and names of the songs in the ROM currently loaded in memory
            SCREENS_print_current_rom_info();					
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;

		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_LOADED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  Selected  ROM file  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  has been loaded to  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  RAM and is running. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;

		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_ACCESS_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   SD card unit or    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"     file access      ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"       error.         ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();		
			break;
			
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_FORMAT_VER_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"    Error opening    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  selected ROM file. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
		
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_CANCELLED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Load &  run ROM    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"   file cancelled.    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();		
			break;
			
		default:
			i8_ret_val = -1;
			break;
				
	}//switch

	return i8_ret_val;
	
}//SCREENS_dialog_show_LOAD_RUN_ROM_FILE



int8_t SCREENS_dialog_ev_manager_LOAD_RUN_ROM_FILE(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	int8_t i8_ret_val = 1;	
	int16_t i16_aux=0;	


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_MOUNTING:	
				
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Load and run ROM file" ,0);			
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait...",0);
				SCREENS_print_help("",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
					
			}//if		
		
			// check if the time to show the specified time to show the message has passed or
			// if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				 
				 i16_aux=FILE_SYS_mount("", 1);
				 if (i16_aux<0){
					
					// load dialog that shows unit mount error					
				 	SCREENS_dialog_load(SCREEN_DIALOG_ID_LOAD_RUN_ROM_FILE,SCREEN_DIALOG_LOAD_RUN_ROM_FILE_ACCESS_ERROR);
					 
				 }else{

					i16_aux = FILE_SYS_dir_open("");
					if (i16_aux<0){
						
						// load dialog that shows the open directory error
						SCREENS_dialog_load(SCREEN_DIALOG_ID_LOAD_RUN_ROM_FILE,SCREEN_DIALOG_LOAD_RUN_ROM_FILE_ACCESS_ERROR);
					
					}else{
						
						// load the file explorer screen
						SCREENS_f_explorer_load(SCREEN_F_EXPLORER_LOAD_RUN_ROM_FILE, SCREEN_F_EXPLORER_INITIAL_STATE);
						
					}//if				 

				 }//if
					
			}//if
			break;
	
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_LOADED:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
		
				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )			
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Load ROM file to RAM",0);		
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to continue.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
			    SCREENS_dialog_show();
			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load dialog the following dialog that shows running file state
					SCREENS_dialog_load(SCREEN_DIALOG_ID_LOAD_RUN_ROM_FILE,SCREEN_DIALOG_LOAD_RUN_ROM_FILE_RUNNING_FILE);
				
			}//if
			break;


		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_RUNNING_FILE:
	
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
			
				// print in screen the title of the new loaded menu
				SCREENS_print_title(ui8_dpack_title_buffer,0);
		
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("ROM running. Press song",0);
				SCREENS_print_help("stop and then any key.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
			    SCREENS_dialog_show();
			
			}//if
			
			// switch on the YELLOW LED to indicate that the system is busy emulating the cart
			GPIO_SetCtrlLinesOutput(VAR_CTRL_GPIO03);

			// to grant proper assembly execution and signals timings while reading the ROM Pack content, disable all  
			// interrupts and keep only the interrupts used to detect changes on the ROM pack CLCK2 line
            GPIO_KeepOnlyDrivePackInterrupts();

			// bus initialization: start with control lines. When emulating the ROM PACK ctrl lines stay always in input mode
			config_ctrl_lines_as_input();     // call function to set CTRL lines to INPUT
			config_data_lines_as_input();	  // call function to set DATA lines to INPUT
             
			// ################ begin: call assembly routine that emulates ROM PACK until any key is pressed
			while ((PORT->Group[0].IN.reg&P0_USER_IFACE_PUSHB_ANY)==P0_USER_IFACE_PUSHB_ANY){
				dpack_int_main();
			}//while
			// ################ end: call assembly routine that emulates ROM PACK

			// once the ROM Pack has been emulated then restore interrupts, and disable the interrupts used to 
			// sample ROM Pack CLKC1 and CLCK2 signals
            GPIO_RestoreAllSystemInterrupts();
			
			// switch off the YELLOW LED and others used to indicate that the system has stopped emulating the cart
			GPIO_SetCtrlLinesOutput(0x00);

			// load the structure of the menu pointed by menu_to_jump
			SCREENS_menus_load(SCREEN_MENU_CURRENT);
					
			break;
		
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_ACCESS_ERROR:
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_FORMAT_VER_ERROR:
		case SCREEN_DIALOG_LOAD_RUN_ROM_FILE_CANCELLED:	
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Load and run ROM file" ,0);			
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key ",0);
				SCREENS_print_help("leave.",1);
								
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
				
			}//if

			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
					
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);	
			}//if
			break;
			
		default:
			i8_ret_val = -1;
			break;
		
	}//switch
	
	return i8_ret_val;	
	
}//SCREENS_dialog_ev_manager_LOAD_RUN_ROM_FILE



int8_t SCREENS_dialog_load_INTRO(){
	int8_t i8_ret_val = 1;

	
	// update the current dialog screen
	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_INTRO_INIT:		
			break;

		default:
			i8_ret_val = -1;
			break;

	}//switch

	return i8_ret_val;

}//SCREENS_dialog_load_INTRO



int8_t SCREENS_dialog_show_INTRO(uint8_t * ui8_message){
	int8_t i8_ret_val = 1;

	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_INTRO_INIT:
		
		    // paint the image with the logo
			GRAPHIX_print_img_from_mem(0, 0, img_size[0],img_size[1],1,img_data,(sizeof(img_data)/sizeof(uint16_t)));			
			// paint the red band with the text in the middle of the screen
			LCD_ST7735_fast_fill (LCD_COLOR_RED, 0,74, 158, 90);// creates the RED rectangle on the INTRO screen
			GRAPHIX_print_string(8, 78, 1, 1, LCD_COLOR_WHITE, LCD_COLOR_RED, "Firmware version ");
			GRAPHIX_print_string(125, 78, 1, 1, LCD_COLOR_WHITE, LCD_COLOR_RED, SW_VERSION);

			// paint the black band with the text at the bottom of the screen
			LCD_ST7735_fast_fill (LCD_COLOR_BLACK, 0,90, 159, 127);		
			GRAPHIX_print_string(5,96, 1, 1, LCD_COLOR_BLACK, LCD_COLOR_WHITE, "R");
			GRAPHIX_print_string(13,96, 1, 1, LCD_COLOR_WHITE, LCD_COLOR_BLACK, "OM cartridge emulator");
			
			GRAPHIX_print_string(18,106, 1, 1, LCD_COLOR_BLACK, LCD_COLOR_WHITE, "J");
			GRAPHIX_print_string(26,106, 1, 1, LCD_COLOR_WHITE, LCD_COLOR_BLACK, ".Bartolome 2022");

			GRAPHIX_print_string(5,116, 1, 1, LCD_COLOR_BLACK, LCD_COLOR_WHITE, "W");
			GRAPHIX_print_string(13,116, 1, 1, LCD_COLOR_WHITE, LCD_COLOR_BLACK, "ww.tolaemon.com/dpack");
			break;

		default:
			i8_ret_val = -1;
			break;
		
	}//switch

	return i8_ret_val;

}//SCREENS_dialog_show_INTRO



int8_t SCREENS_dialog_ev_manager_INTRO(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	int8_t i8_ret_val = 1;


    switch (screens_dialog.i8_state){
		  
		  case SCREEN_DIALOG_INITIAL_STATE:
		  case SCREEN_DIALOG_INTRO_INIT:
		  
				// in the on-load event show screen for first time
				if (screens_control.ui8_on_load_event==TRUE){
				
					// reset the OnLoad event flag
					screens_control.ui8_on_load_event = FALSE;
				
					// show current dialog screen
					SCREENS_dialog_show();
					
				}//if		  
		  
				// check if the time to show the specified time to show the message has passed or
				// if the user has pressed any key
				if (  pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
					
					// clear the bitmap and all the parts of the INTRO that may remain in the screen
					LCD_ST7735_fast_fill (LCD_COLOR_BLACK, 0,0, 159, 127);
					
					// as that INTRO dialog shows on the screen the image with the logo and other drawings
					// ( it does not use the text buffer ) we have to set the REFRESH attribute of all 
					// characters of the buffer to '1' to force them to be rewritten is screen.
					GRAPHIX_text_buffer_fill_attr(ATTR_REFRESH);
					  
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
				  			  
				}//TIMING_CheckTicksDelayReached
			    break;
			   
		default:
			i8_ret_val = -1;
			break;
			   			   	  	  
	}//switch

	return i8_ret_val;
	
}//SCREENS_dialog_ev_manager_INTRO



int8_t SCREENS_dialog_load_RUN_RAM(){
	int8_t i8_ret_val = 1;


	// update the current dialog screen
	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_RUN_RAM_CHECK:
			break;
			
	    case SCREEN_DIALOG_RUN_RAM_RUNNING:		
			break;

		case SCREEN_DIALOG_RUN_RAM_NO_LOADED_ERROR:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);
			break;
				
		default:
			i8_ret_val = -1;
			break;
						
	}//switch

	return i8_ret_val;

}//SCREENS_dialog_load_RUN_RAM



int8_t SCREENS_dialog_show_RUN_RAM(uint8_t * ui8_message){
	int8_t i8_ret_val = 1;


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_RUN_RAM_CHECK:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"  Checking if there   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   is valid data to   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  run in RAM buffer.  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"       Wait ...       ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();	
			break;		
			
		case SCREEN_DIALOG_RUN_RAM_RUNNING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);		
			// call the function that shows in the LCD the number and names of the songs in the ROM currently loaded in memory
            SCREENS_print_current_rom_info();					
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;

		case SCREEN_DIALOG_RUN_RAM_NO_LOADED_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer			
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  Error, there is no  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  valid data  in RAM  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"    buffer to run.    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();		
			break;
				
		default:
			i8_ret_val = -1;
			break;
				
	}//switch

	return i8_ret_val;
	
}//SCREENS_dialog_show_RUN_RAM



int8_t SCREENS_dialog_ev_manager_RUN_RAM(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	int8_t i8_ret_val = 1;	


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_RUN_RAM_CHECK:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Run file in RAM" ,0);			
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait...",0);
				SCREENS_print_help("",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();		
		
			}//if
	
			// check the flag that indicates if there is valid data in the memory buffer and show the corresponding message
			if (ui8_dpack_dumper_buffer_initialized == FALSE){
			
				// load dialog that shows that there is no valid data loaded into memory buffer
				SCREENS_dialog_load(SCREEN_DIALOG_ID_RUN_RAM,SCREEN_DIALOG_RUN_RAM_NO_LOADED_ERROR);			
			
			}else{
			
				// load the dialog that runs the current data stored in memory buffer
				SCREENS_dialog_load(SCREEN_DIALOG_ID_RUN_RAM,SCREEN_DIALOG_RUN_RAM_RUNNING);			
			
			}//if
			break;
						
		case SCREEN_DIALOG_RUN_RAM_RUNNING:
	
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )			
				// print in screen the title of the new loaded menu
				// SCREENS_print_title(ui8_dpack_title_buffer,0);		
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("RAM running. Press song",0);
				SCREENS_print_help("stop and then any key.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
			    SCREENS_dialog_show();
			
			}//if
			
			// switch on the YELLOW LED to indicate that the system is busy emulating the cart
			GPIO_SetCtrlLinesOutput(VAR_CTRL_GPIO03);

			// to grant proper assembly execution and signals timings while reading the ROM Pack content, disable all
			// interrupts and keep only the interrupts used to detect changes on the ROM pack CLCK2 line
			GPIO_KeepOnlyDrivePackInterrupts();

			// bus initialization: start with control lines. When emulating the ROM PACK ctrl lines stay always in input mode
			config_ctrl_lines_as_input();     // call function to set CTRL lines to INPUT
			config_data_lines_as_input();	  // call function to set DATA lines to INPUT
			
			// ################ begin: call assembly routine that emulates ROM PACK until any key is pressed
			while ((PORT->Group[0].IN.reg&P0_USER_IFACE_PUSHB_ANY)==P0_USER_IFACE_PUSHB_ANY){
				dpack_int_main();
			}//while
			// ################ end: call assembly routine that emulates ROM PACK

			// once the ROM Pack has been emulated then restore interrupts, and disable the interrupts used to
			// sample ROM Pack CLKC1 and CLCK2 signals
			GPIO_RestoreAllSystemInterrupts();
			
			// switch off the YELLOW LED and others used to indicate that the system has stopped emulating the cart
			GPIO_SetCtrlLinesOutput(0x00);
					
			// load the structure of the menu pointed by menu_to_jump
			SCREENS_menus_load(SCREEN_MENU_CURRENT);
					
			break;
		
		case SCREEN_DIALOG_RUN_RAM_NO_LOADED_ERROR:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
	
				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )	
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Run file in RAM" ,0);				
				// update the help content lines in screen according to new loaded menu
				// SCREENS_print_help("Wait or press any key ",0);
				// SCREENS_print_help("leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
				
			}//if

			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
					
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);	
			}//if
			break;
			
		default:
			i8_ret_val = -1;
			break;
		
	}//switch
	
	return i8_ret_val;	
	
}//SCREENS_dialog_ev_manager_RUN_RAM



int8_t SCREENS_dialog_load_SHOW_RAM_INFO(){
	int8_t i8_ret_val = 1;


	// update the current dialog screen
	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_SHOW_RAM_INFO_CHECK:
			break;
			
	    case SCREEN_DIALOG_SHOW_RAM_INFO_SHOWING_1:
		case SCREEN_DIALOG_SHOW_RAM_INFO_SHOWING_2:
			break;

		case SCREEN_DIALOG_SHOW_RAM_INFO_NO_LOADED_ERROR:
		case SCREEN_DIALOG_SHOW_RAM_INFO_NO_FILE_ERROR:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);
			break;
				
		default:
			i8_ret_val = -1;
			break;
						
	}//switch

	return i8_ret_val;

}//SCREENS_dialog_load_SHOW_RAM_INFO



int8_t SCREENS_dialog_show_SHOW_RAM_INFO(uint8_t * ui8_message){
	int8_t i8_ret_val = 1;
	uint8_t ui8_aux_string[AUX_FUNCS_F_P_MAX_STR_SIZE_64];
	

	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_SHOW_RAM_INFO_CHECK:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  Checking if there   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   is valid data to   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"     show in RAM.     ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"       Wait ...       ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();	
			break;		

		case SCREEN_DIALOG_SHOW_RAM_INFO_SHOWING_1:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);		
			// call the function that shows in the LCD the number and names of the songs in the ROM currently loaded in memory
            SCREENS_print_current_rom_info();					
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;

		case SCREEN_DIALOG_SHOW_RAM_INFO_SHOWING_2:				
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)" Current file in  RAM ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   buffer name is ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// center entered file name before placing it in the screen buffer
			AUX_FUNCS_lstrfill(ui8_aux_string,' ',GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
			AUX_FUNCS_center_into_string(ui8_aux_string, ui8_dpack_file_name,0,GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)ui8_aux_string,ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)" and is saved in path",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// center current file system path before printing it in the screen
			AUX_FUNCS_lstrfill(ui8_aux_string,' ',GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
			AUX_FUNCS_center_into_string(ui8_aux_string,ui8_dpack_file_path,0,GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
			// place entered text in screen buffer
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)ui8_aux_string,ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();

			break;

		case SCREEN_DIALOG_SHOW_RAM_INFO_NO_LOADED_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  Error, there is no  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  valid data  in RAM  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"    buffer to show.   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();		
			break;

		case SCREEN_DIALOG_SHOW_RAM_INFO_NO_FILE_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"   Error,  no valid   ", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   file information", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"     has been set.   ", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  Use 'save file as'", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)" option  to set name.", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();		
			break;
			
		default:
			i8_ret_val = -1;
			break;
				
	}//switch

	return i8_ret_val;
	
}//SCREENS_dialog_show_SHOW_RAM_INFO



int8_t SCREENS_dialog_ev_manager_SHOW_RAM_INFO(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	int8_t i8_ret_val = 1;	


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_SHOW_RAM_INFO_CHECK:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Show RAM file info" ,0);			
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait...",0);
				SCREENS_print_help("",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();		
		
			}//if
	
			// check the flag that indicates if there is valid data in the memory buffer and show the corresponding message
			if (ui8_dpack_dumper_buffer_initialized == FALSE){
			
				// load dialog that shows that there is no valid data loaded into memory buffer
				SCREENS_dialog_load(SCREEN_DIALOG_ID_SHOW_RAM_INFO,SCREEN_DIALOG_SHOW_RAM_INFO_NO_LOADED_ERROR);			
			
			}else{
			
				// load the dialog that shows the screens with current RAM content songs information
				SCREENS_dialog_load(SCREEN_DIALOG_ID_SHOW_RAM_INFO,SCREEN_DIALOG_SHOW_RAM_INFO_SHOWING_1);			
			
			}//if
			break;
				
		case SCREEN_DIALOG_SHOW_RAM_INFO_SHOWING_1:
	
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
			
				// print in screen the title of the new loaded menu
				SCREENS_print_title(ui8_dpack_title_buffer,0);		
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Press any key to show  ",0);
				SCREENS_print_help("next info screen.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
			    SCREENS_dialog_show();
			
			}//if

			// check if the user has pressed the key to leave current screen
			if ( pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED ){
				
				// load the structure of the menu pointed by menu_to_jump
				SCREENS_menus_load(SCREEN_MENU_CURRENT);			
				
			}//if

			// check if the user has pressed any of the following keys
			if ( pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
			
			    // check if the file information of the current RAM buffer content has been set
				if (AUX_FUNCS_lstrlen(ui8_dpack_file_name,MAX_ROM_FILE_NAME)<=0){

					// if a file name has not been set then show the corresponding error message
					SCREENS_dialog_load(SCREEN_DIALOG_ID_SHOW_RAM_INFO,SCREEN_DIALOG_SHOW_RAM_INFO_NO_FILE_ERROR);
								
				}else{
					
					// load the dialog that shows the next screen with current RAM content songs information
					SCREENS_dialog_load(SCREEN_DIALOG_ID_SHOW_RAM_INFO,SCREEN_DIALOG_SHOW_RAM_INFO_SHOWING_2);
					
				}//if
										
			}//if					
			break;				
				
		case SCREEN_DIALOG_SHOW_RAM_INFO_SHOWING_2:
	
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
			
				// print in screen the title of the new loaded menu
				SCREENS_print_title(ui8_dpack_title_buffer,0);		
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Press left key to show ",0);
				SCREENS_print_help("previous info screen.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
			    SCREENS_dialog_show();
			
			}//if

			// check if the user has pressed any of the left key to go to previous screen
			if ( pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED ){
	
				// load the dialog that shows the next screen with current RAM content songs information
				SCREENS_dialog_load(SCREEN_DIALOG_ID_SHOW_RAM_INFO,SCREEN_DIALOG_SHOW_RAM_INFO_SHOWING_1);
	
			}//if

			// check if the user has pressed any of the following keys
			if ( pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
				      // load the structure of the menu pointed by menu_to_jump
				      SCREENS_menus_load(SCREEN_MENU_CURRENT);			
			}//if					
			break;
	
		case SCREEN_DIALOG_SHOW_RAM_INFO_NO_LOADED_ERROR:
		case SCREEN_DIALOG_SHOW_RAM_INFO_NO_FILE_ERROR:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )					
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Show RAM file info" ,0);				
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("leave.",1);
						
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
				
			}//if

			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
					
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);	
			}//if
			break;
			
		default:
			i8_ret_val = -1;
			break;
		
	}//switch
	
	return i8_ret_val;	
	
}//SCREENS_dialog_ev_manager_SHOW_RAM_INFO



int8_t SCREENS_dialog_load_DUMP_ROM(){
	int8_t i8_ret_val = 1;


	// update the current dialog screen
	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_DUMP_ROM_PREPARE:
			break;
			
	    case SCREEN_DIALOG_DUMP_ROM_DUMPING:		
			break;

		case SCREEN_DIALOG_DUMP_ROM_CHECK_ERROR:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);
			break;

		case SCREEN_DIALOG_DUMP_ROM_DUMPED:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);
			break;
			
		case SCREEN_DIALOG_DUMP_ROM_CANCELLED:
		    screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);
			break;
			
		default:
			i8_ret_val = -1;
			break;
						
	}//switch

	return i8_ret_val;

}//SCREENS_dialog_load_DUMP_ROM



int8_t SCREENS_dialog_show_DUMP_ROM(uint8_t * ui8_message){
	int8_t i8_ret_val = 1;


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_DUMP_ROM_PREPARE:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"  Place the ROM cart  ", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)" to read in  the read ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   header and  then   ", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"   press any key to   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"      continue.       ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();	
			break;		

		case SCREEN_DIALOG_DUMP_ROM_DUMPING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   Reading ROM cart   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)" content and  storing ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)" data in  RAM buffer. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"      Wait ...        ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;

		case SCREEN_DIALOG_DUMP_ROM_DUMPED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"   The  content of  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  ROM cart has been ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  successfully read ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  and stored in RAM ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"        buffer.     ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();		
			break;

		case SCREEN_DIALOG_DUMP_ROM_CHECK_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"  Read ROM cart data ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  is invalid.  Check ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  cart   connections ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  and  confirm  that ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"      ROM cart is    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,8,(uint8_t*)"   properly placed.  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();		
			break;		
			
		case SCREEN_DIALOG_DUMP_ROM_CANCELLED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   Dump ROM content ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"    to RAM buffer   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"      cancelled.    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;		
				
		default:
			i8_ret_val = -1;
			break;
				
	}//switch

	return i8_ret_val;
	
}//SCREENS_dialog_show_DUMP_ROM



int8_t SCREENS_dialog_ev_manager_DUMP_ROM(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	int8_t i8_ret_val = 1;	


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_DUMP_ROM_PREPARE:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Dump ROM cart to RAM" ,0);				
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Place ROM cart and",0);
				SCREENS_print_help("press any key.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();		
		
			}//if

			// check if the the user presses the key to cancel operation
			if ( 	pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED){
												
					// load dialog that shows that the user has cancelled current operation
					SCREENS_dialog_load(SCREEN_DIALOG_ID_DUMP_ROM,SCREEN_DIALOG_DUMP_ROM_CANCELLED);
				
			}//if

			// check if the the user presses any key to start dumping
			if (	pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
					
					// load dialog that dumps the ROM content and shows the corresponding message
					SCREENS_dialog_load(SCREEN_DIALOG_ID_DUMP_ROM,SCREEN_DIALOG_DUMP_ROM_DUMPING);
					
			}//if
	
			break;
				
		case SCREEN_DIALOG_DUMP_ROM_DUMPING:
	
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )			
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Dump ROM cart to RAM" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait until whole ROM has",0);
				SCREENS_print_help("been dumped to RAM.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
			    SCREENS_dialog_show();
			
			}//if
			
			// switch on the YELLOW LED to indicate that the system is busy emulating the cart
			GPIO_SetCtrlLinesOutput(VAR_CTRL_GPIO03);

			// initialize all the buffers and variables in RAM used to store the information of the ROM PACK
			DPACK_CTRL_Init();

			// to grant proper assembly execution and signals timings while
			// reading the ROM Pack content, dissable interrupts
			__disable_irq();

			// call assembly routine that reads ROM PACK content
			dpack_dumper_main();

			// once the content of the ROM Pack has been read, then restore interrupts
			__enable_irq();

			// switch off the YELLOW LED and others used to indicate that the system has stopped emulating the cart
			GPIO_SetCtrlLinesOutput(0x00);
			
			// after reading check that the data stored in the RAM buffer corresponds to a valid ROM pack 
			if (DPACK_CTRL_check_buffer()>=0){
				
			   ui8_dpack_dumper_buffer_initialized = TRUE;
			
			   AUX_FUNCS_lstrcpy(ui8_dpack_title_buffer,"RO-??? Title?",MAX_ROM_TITLE_BUFFER);
			   AUX_FUNCS_lstrcpy(ui8_dpack_songs_info_buffer,"ROM songs information has not been initialized yet.\r\nUse drivePackEd software to enter the ROM songs and other information in the file.",MAX_ROM_SONGS_INFO_BUFFER);
			
               // load dialog that informs that data has been properly read and dumped to RAM buffer
               SCREENS_dialog_load(SCREEN_DIALOG_ID_DUMP_ROM,SCREEN_DIALOG_DUMP_ROM_DUMPED);
			   
			}else{
				
               // load dialog that informs that it was not possible to dump ROM content to RAM buffer
               SCREENS_dialog_load(SCREEN_DIALOG_ID_DUMP_ROM,SCREEN_DIALOG_DUMP_ROM_CHECK_ERROR);
            
			}//if

			break;
	
		case SCREEN_DIALOG_DUMP_ROM_DUMPED:

			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
		
				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Dump ROM cart to RAM" ,0);		
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
					
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);	
			}//if
			break;
			
		case SCREEN_DIALOG_DUMP_ROM_CHECK_ERROR:

			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
		
				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )		
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Dump ROM cart to RAM" ,0);				
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
					
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);	
			}//if			
			break;
			
		case SCREEN_DIALOG_DUMP_ROM_CANCELLED:

			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
		
				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )		
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Dump ROM cart to RAM" ,0);				
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
					
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);	
			}//if				
			break;
					
		default:
			i8_ret_val = -1;
			break;
		
	}//switch
	
	return i8_ret_val;	
	
}//SCREENS_dialog_ev_manager_DUMP_ROM



int8_t SCREENS_dialog_load_SAVE_RAM_AS_FILE(){
	int8_t i8_ret_val = 1;


	// update the current dialog screen
	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_CHECK:
		    break;
			
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_MOUNTING:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_FAST_MESSAGE_TIMEOUT);			  
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_SAVING_FILE:
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_SAVED:			
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_ACCESS_ERROR:	
        case SCREEN_DIALOG_SAVE_RAM_AS_FILE_SAVING_ERROR:
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_CANCELLED:	
		case SCREEN_DIALOG_SAVE_RAM_AS_NO_LOADED_ERROR:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);		
			break;
			
		default:
			i8_ret_val = -1;
			break;
						
	}//switch

	return i8_ret_val;

}//SCREENS_dialog_load_SAVE_RAM_AS_FILE



int8_t SCREENS_dialog_show_SAVE_RAM_AS_FILE(uint8_t * ui8_message){
	int8_t i8_ret_val = 1;
	uint8_t ui8_aux_string[AUX_FUNCS_F_P_MAX_STR_SIZE_64];
	uint8_t ui8_aux_string2[AUX_FUNCS_F_P_MAX_STR_SIZE_64];


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_CHECK:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"  Checking if there   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  is valid  data to   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   in RAM to save.     ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"       Wait ...       ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();			
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_MOUNTING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer		
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Mounting SD card   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 			
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"    unit. Wait ...    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 			
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
		
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_SAVING_FILE:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"  Saving RAM buffer  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"to specified ROM file ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// center entered file name before placing it in the screen buffer
			AUX_FUNCS_lstrfill(ui8_aux_string,' ',GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE	
			AUX_FUNCS_center_into_string(ui8_aux_string,screens_enter_txt.ui8_text,0,GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)ui8_aux_string,ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);

			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"      in folder      ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// center current file system path before printing it in the screen
			AUX_FUNCS_lstrfill(ui8_aux_string,' ',GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE	
			FILE_SYS_get_cur_dir(ui8_aux_string2,AUX_FUNCS_F_P_MAX_STR_SIZE_64-1);
			AUX_FUNCS_center_into_string(ui8_aux_string,ui8_aux_string2,0,GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
			// place entered text in screen buffer
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)ui8_aux_string,ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
	
			GRAPHIX_text_buffer_set_string(0,8,(uint8_t*)"       Wait...       ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();			
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_SAVED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"     RAM  content    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  successfully saved ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"     to specified    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"       ROM file.     ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;

		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_ACCESS_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   SD card unit or    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"     file access      ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"       error.         ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_SAVING_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  Error while saving  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)" RAM buffer  to file.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();		
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_CANCELLED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Save RAM buffer   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  to file cancelled.  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();			
			break;

		case SCREEN_DIALOG_SAVE_RAM_AS_NO_LOADED_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  Error, there is no  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  valid data  in RAM  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"    buffer to save.   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
				
		default:
			i8_ret_val = -1;
			break;
				
	}//switch

	return i8_ret_val;
	
}//SCREENS_dialog_show_SAVE_RAM_AS_FILE



int8_t SCREENS_dialog_ev_manager_SAVE_RAM_AS_FILE(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	int8_t i8_ret_val = 1;	
	int16_t i16_aux=0;	


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_CHECK:

			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Save RAM as file",0);			
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait ...",0);
				SCREENS_print_help("",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
				
			}//if
	
			// check the flag that indicates if there is valid data in the memory buffer and show the corresponding message
			if (ui8_dpack_dumper_buffer_initialized == FALSE){
				
				// load dialog that shows that there is no valid data loaded into memory buffer
				SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_AS_FILE,SCREEN_DIALOG_SAVE_RAM_AS_NO_LOADED_ERROR);
				
			}else{
				
				// load the dialog that mounts the unit to start navigating the folders
				SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_AS_FILE,SCREEN_DIALOG_SAVE_RAM_AS_FILE_MOUNTING);
				
			}//if
			break;	
			
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_MOUNTING:	
				
			// in the on load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

			    // lines commented because the title and help are the same than the
			    // previous screen and there is no need to rewrite them ( it causes
			    // an undesired flicker )
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Save RAM to file",0);				
				// update the help content lines in screen according to new loaded menu
				// SCREENS_print_help("Wait...",0);
				// SCREENS_print_help("",1);
							
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
					
			}//if		
		
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				 
				 i16_aux=FILE_SYS_mount("", 1);
				 if (i16_aux<0){
					
					// load dialog that shows unit mount error
				 	SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_AS_FILE,SCREEN_DIALOG_SAVE_RAM_AS_FILE_ACCESS_ERROR);						
				 
				 }else{

					i16_aux = FILE_SYS_dir_open("");
					if (i16_aux<0){
						
						// load dialog that shows the open directory error 
						SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_AS_FILE,SCREEN_DIALOG_SAVE_RAM_AS_FILE_ACCESS_ERROR);
					
					}else{
						
						// load the file explorer screen
						SCREENS_f_explorer_load(SCREEN_F_EXPLORER_SAVE_RAM,SCREEN_F_EXPLORER_INITIAL_STATE);
						
					}//if				 

				 }//if
					
			}//if
			break;

		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_SAVING_FILE:
		
			// in the onload event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Save RAM to file",0);			
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait...",0);
				SCREENS_print_help("",1);
			
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			
			}//if
			
			// save current RAM buffer content to file with entered name
			i8_ret_val = (int8_t)AUX_FUNCS_lstrlen(screens_enter_txt.ui8_text, MAX_ENTER_TEXT_LEN);
			if (i8_ret_val<0){
							
				// load dialog that shows the saving RAM buffer content to file error
				SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_AS_FILE,SCREEN_DIALOG_SAVE_RAM_AS_FILE_SAVING_ERROR);
								
			}else{
				
			    // try to save RAM buffer content to the specified file ( path should have been previously set in the right folder )
				// the file name should have been previously stored in "screens_enter_txt.ui8_text" before calling this function
				i8_ret_val = (int8_t)DATA_IO_file_rom_write(screens_enter_txt.ui8_text);
			    if (i8_ret_val>=0){
									
					// load dialog that shows the saving RAM buffer content success 
					SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_AS_FILE,SCREEN_DIALOG_SAVE_RAM_AS_FILE_SAVED);	
														
				}else{
									
					// load dialog that shows the saving RAM buffer content to file error
					SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_AS_FILE,SCREEN_DIALOG_SAVE_RAM_AS_FILE_SAVING_ERROR);	
							
				}//if
			
			}//if
			break;

		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_SAVED:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
			
			    // lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes 
				// an undesired flicker )
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Save RAM buffer to file",0);		
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
			    SCREENS_dialog_show();
			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
				
			}//if
			break;

		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_ACCESS_ERROR:
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_SAVING_ERROR:
		case SCREEN_DIALOG_SAVE_RAM_AS_FILE_CANCELLED:
		case SCREEN_DIALOG_SAVE_RAM_AS_NO_LOADED_ERROR:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

			    // lines commented because the title and help are the same than the
			    // previous screen and there is no need to rewrite them ( it causes
			    // an undesired flicker )
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Save RAM to file",0);				
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
				
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
				
			}//if						
			break;
			
		default:
			i8_ret_val = -1;
			break;
		
	}//switch
	
	return i8_ret_val;	
	
	
}//SCREENS_dialog_ev_manager_SAVE_RAM_AS_FILE



int8_t SCREENS_dialog_load_SAVE_RAM_FILE(){
	int8_t i8_ret_val = 1;


	// update the current dialog screen
	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_SAVE_RAM_FILE_CHECK:	
		    break;
				
		case SCREEN_DIALOG_SAVE_RAM_FILE_MOUNTING:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_FAST_MESSAGE_TIMEOUT);			  
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_FILE_SAVING_FILE:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);			
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_FILE_SAVED:			
		case SCREEN_DIALOG_SAVE_RAM_FILE_ACCESS_ERROR:	
        case SCREEN_DIALOG_SAVE_RAM_FILE_SAVING_ERROR:
		case SCREEN_DIALOG_SAVE_RAM_FILE_CANCELLED:
		case SCREEN_DIALOG_SAVE_RAM_FILE_NO_FILE_ERROR:
		case SCREEN_DIALOG_SAVE_RAM_FILE_NO_LOADED_ERROR:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);		
			break;
			
		default:
			i8_ret_val = -1;
			break;
						
	}//switch

	return i8_ret_val;

}//SCREENS_dialog_load_SAVE_RAM_FILE



int8_t SCREENS_dialog_show_SAVE_RAM_FILE(uint8_t * ui8_message){
	int8_t i8_ret_val = 1;
	uint8_t ui8_aux_string[AUX_FUNCS_F_P_MAX_STR_SIZE_64];


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_SAVE_RAM_FILE_CHECK:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"  Checking if there   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  is valid  data to   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   in RAM to save.     ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"       Wait ...       ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();			
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_FILE_MOUNTING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer		
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Mounting SD card   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 			
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"    unit. Wait ...    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 			
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
		
		case SCREEN_DIALOG_SAVE_RAM_FILE_SAVING_FILE:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"  Saving RAM buffer  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)" to current ROM file ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// center entered file name before placing it in the screen buffer
			AUX_FUNCS_lstrfill(ui8_aux_string,' ',GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE	
			AUX_FUNCS_center_into_string(ui8_aux_string,ui8_dpack_file_name,0,GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)ui8_aux_string,ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);

			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"       in path      ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// center current file system path before printing it in the screen
			AUX_FUNCS_lstrfill(ui8_aux_string,' ',GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE	
            AUX_FUNCS_center_into_string(ui8_aux_string,ui8_dpack_file_path,0,GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
			// place entered text in screen buffer
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)ui8_aux_string,ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
	
			GRAPHIX_text_buffer_set_string(0,8,(uint8_t*)"       Wait...       ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();			
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_FILE_SAVED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"    RAM  buffer    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)" successfully saved",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   to current ROM  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"    file in disk.  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;

		case SCREEN_DIALOG_SAVE_RAM_FILE_ACCESS_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   SD card unit or    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"     file access      ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"       error.         ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_FILE_SAVING_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  Error while saving  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)" RAM buffer  to file. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();		
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_FILE_CANCELLED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Save RAM buffer   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  to file cancelled. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK); 
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();			
			break;

		case SCREEN_DIALOG_SAVE_RAM_FILE_NO_FILE_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"   Error,  no valid   ", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   file information", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"     has been set.   ", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  Use save 'file as'", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)" option  to set name.", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();			
			break;
			
		case SCREEN_DIALOG_SAVE_RAM_FILE_NO_LOADED_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  Error, there is no  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  valid data  in RAM  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"   buffer to save.    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
				
		default:
			i8_ret_val = -1;
			break;
				
	}//switch

	return i8_ret_val;
	
}//SCREENS_dialog_show_SAVE_RAM_FILE



int8_t SCREENS_dialog_ev_manager_SAVE_RAM_FILE(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	int8_t i8_ret_val = 1;	
	int16_t i16_aux=0;	


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_SAVE_RAM_FILE_CHECK:

			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Save RAM to file",0);			
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait ...",0);
				SCREENS_print_help("",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
				
			}//if
	
			// check the flag that indicates if there is valid data in the memory buffer and show the corresponding message
			if (ui8_dpack_dumper_buffer_initialized == FALSE){
				
				// load dialog that shows that there is no valid data loaded into memory buffer
				SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_FILE,SCREEN_DIALOG_SAVE_RAM_FILE_NO_LOADED_ERROR);
				
			}else{
				
				// get the length of the file name to check if the file information ( name, path... ) needed to save the file is initialized
			    if (AUX_FUNCS_lstrlen(ui8_dpack_file_name,MAX_ROM_FILE_NAME)<=0){

				    // if a file name has not been set then show the corresponding error message
				    SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_FILE,SCREEN_DIALOG_SAVE_RAM_FILE_NO_FILE_ERROR);
				    
				}else{
				    
					// load the dialog that mounts the unit and moves to the target path
					SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_FILE,SCREEN_DIALOG_SAVE_RAM_FILE_MOUNTING);
				    
			    }//if				
				
			}//if
			break;	
			
		case SCREEN_DIALOG_SAVE_RAM_FILE_MOUNTING:	
				
			// in the on load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

			    // lines commented because the title and help are the same than the
			    // previous screen and there is no need to rewrite them ( it causes
			    // an undesired flicker )
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Save RAM to file",0);				
				// update the help content lines in screen according to new loaded menu
				// SCREENS_print_help("Wait...",0);
				// SCREENS_print_help("",1);
							
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
					
			}//if		
		
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				 pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				 
				 i16_aux=FILE_SYS_mount("", 1);
				 if (i16_aux<0){
					
					// load dialog that shows unit mount error
				 	SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_FILE,SCREEN_DIALOG_SAVE_RAM_FILE_ACCESS_ERROR);						
				 
				 }else{

					i16_aux = FILE_SYS_dir_open(ui8_dpack_file_path);
					if (i16_aux<0){
						
						// load dialog that shows the open directory error 
						SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_FILE,SCREEN_DIALOG_SAVE_RAM_FILE_ACCESS_ERROR);
					
					}else{
						
						// load dialog that saves the current file
						SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_FILE,SCREEN_DIALOG_SAVE_RAM_FILE_SAVING_FILE);
						
					}//if				 

				 }//if
					
			}//if
			break;

		case SCREEN_DIALOG_SAVE_RAM_FILE_SAVING_FILE:
		
			// in the onload event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Save RAM to file",0);			
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait...",0);
				SCREENS_print_help("",1);
			
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			
			}//if

			// wait a short pause to show the operation information before saving the file content
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
			
					// try to save RAM buffer content to the specified file ( path should have been previously set in the right folder )
					i8_ret_val = (int8_t)DATA_IO_file_rom_write(ui8_dpack_file_name);
					if (i8_ret_val>=0){
										
						// load dialog that shows the saving RAM buffer content success 
						SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_FILE,SCREEN_DIALOG_SAVE_RAM_FILE_SAVED);	
															
					}else{
											
						// load dialog that shows the saving RAM buffer content to file error
						SCREENS_dialog_load(SCREEN_DIALOG_ID_SAVE_RAM_FILE,SCREEN_DIALOG_SAVE_RAM_FILE_SAVING_ERROR);
									
					}//if
			
			}//if
			break;

		case SCREEN_DIALOG_SAVE_RAM_FILE_SAVED:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){
			
			    // lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes 
				// an undesired flicker )
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Save RAM buffer to file",0);		
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
			    SCREENS_dialog_show();
			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
				
			}//if
			break;

		case SCREEN_DIALOG_SAVE_RAM_FILE_ACCESS_ERROR:
		case SCREEN_DIALOG_SAVE_RAM_FILE_SAVING_ERROR:
		case SCREEN_DIALOG_SAVE_RAM_FILE_CANCELLED:
		case SCREEN_DIALOG_SAVE_RAM_FILE_NO_FILE_ERROR:
		case SCREEN_DIALOG_SAVE_RAM_FILE_NO_LOADED_ERROR:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

			    // lines commented because the title and help are the same than the
			    // previous screen and there is no need to rewrite them ( it causes
			    // an undesired flicker )
				// print in screen the title of the new loaded menu
				// SCREENS_print_title("Save RAM to file",0);				
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
				
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
				
			}//if						
			break;
			
		default:
			i8_ret_val = -1;
			break;
		
	}//switch
	
	return i8_ret_val;	
	
	
}//SCREENS_dialog_ev_manager_SAVE_RAM_FILE



int8_t SCREENS_dialog_load_RECEIVE_RUN_RAM(){
	int8_t i8_ret_val = 1;


	// update the current dialog screen
	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_WAITING:
		    ui8_usart_1kX_retries = USART_1KXMODEM_RX_RETRIES;			
			screens_dialog.timer = TIMING_SetTicksDelay(0);// use dialog timer to manage 1kXmodem conection timeouts and retries
			break;
	
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_RECEIVING:
			break;	

		case SCREEN_DIALOG_RECEIVE_RUN_RAM_RECEIVED:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);	
			break;
	
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_TIMEOUT_ERROR:
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_PROCESS_ERROR:
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_CANCELLED:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);
			break;
			
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_RUNNING:
		    break;	
		
		default:
			i8_ret_val = -1;
			break;
		
	}//switch

	return i8_ret_val;

}//SCREENS_dialog_load_RECEIVE_RUN_RAM



int8_t SCREENS_dialog_show_RECEIVE_RUN_RAM(uint8_t * ui8_message){
	int8_t i8_ret_val = 1;
	uint8_t ui8_aux_string[AUX_FUNCS_F_P_MAX_STR_SIZE_64];
	uint8_t ui8_aux_string2[AUX_FUNCS_F_P_MAX_STR_SIZE_16];

	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_WAITING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"   Use  send option  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)" in remote  computer.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Waiting to start  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"    receiving  RAM   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"   buffer content... ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the number of start transmission retries centered
			AUX_FUNCS_itoa((int32_t)ui8_usart_1kX_retries,ui8_aux_string2,10,AUX_FUNCS_F_P_MAX_STR_SIZE_16);
			AUX_FUNCS_lstrfill(ui8_aux_string,' ',GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
			AUX_FUNCS_center_into_string(ui8_aux_string,ui8_aux_string2,0,GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
			GRAPHIX_text_buffer_set_string(0,9,(uint8_t*)ui8_aux_string,ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
						
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
			
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_RECEIVING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"     Connection ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"    established. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Receiving RAM ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"   buffer content.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"      Wait...",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;		
				
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_RECEIVED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"  RAM buffer content ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"     successfully  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"    received  from ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"   remote computer. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;	

		case SCREEN_DIALOG_RECEIVE_RUN_RAM_TIMEOUT_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"   Error, connection  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   timeout.Could not  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  establish connection",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"      with remote     ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"       computer.      ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
			
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_PROCESS_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"     Error while  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"    receiving RAM ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"   buffer content.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;			

		case SCREEN_DIALOG_RECEIVE_RUN_RAM_CANCELLED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  Receive RAM buffer ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  content cancelled. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
			
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_RUNNING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);		
			// call the function that shows in the LCD the number and names of the songs in the ROM currently loaded in memory
            SCREENS_print_current_rom_info();					
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;

		default:
			i8_ret_val = -1;
			break;
		
	}//switch

	return i8_ret_val;
	
}//SCREENS_dialog_show_RECEIVE_RUN_RAM



int8_t SCREENS_dialog_ev_manager_RECEIVE_RUN_RAM(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	int8_t i8_ret_val = 1;


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_WAITING:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Receive & run RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			
				// disable CONSOLE module to avoid undesired interactions on the serial
				// port while sending the ROM in RAM buffer through the 1KXmodemConnection
				CONSOLE_disable();			
			
			}//if

			// check if the time to show the message has passed or if the user has pressed any key
			if ( /*TIMING_CheckTicksDelayReached(screens_dialog.timer) ||*/
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
		
					// load dialog that shows that the user has cancelled current operation
					SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RUN_RAM,SCREEN_DIALOG_RECEIVE_RUN_RAM_CANCELLED);
		
			}//if
			
			// waiting on each USART_1KXmodem_rx_establish iteration 
			if (TIMING_CheckTicksDelayReached(screens_dialog.timer)){
				
				i8_ret_val = (int8_t)USART_1KXmodem_rx_open();
				if (i8_ret_val==USART_1KX_TOUT_ERR){
					
					screens_dialog.timer = TIMING_SetTicksDelay(TIMMING_TICKS_1_S);	
					ui8_usart_1kX_retries--;
					if (ui8_usart_1kX_retries>0){
												
						// refresh the screen with current number of retries
						SCREENS_dialog_show();
											
					}else{
																
						// load dialog that shows the corresponding start connection timeout error
						SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RUN_RAM,SCREEN_DIALOG_RECEIVE_RUN_RAM_TIMEOUT_ERROR);
										
					}//if
										
				}else{
					
					// check if the first 1KXmodem packet that confirms that 1KXmodem connection has been established has been received
					if (i8_ret_val == USART_1KX_PACKET_OK){
															
						// load the dialog on which the system keeps receiving the ROM sent by the sender ( the remote computer )
						SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RUN_RAM,SCREEN_DIALOG_RECEIVE_RUN_RAM_RECEIVING);
															
					}else{
						
					    // load the dialog that shows the corresponding reception error message
						SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RUN_RAM,SCREEN_DIALOG_RECEIVE_RUN_RAM_PROCESS_ERROR);
								
					}//if

				}//if
					
			}//if					
			break;
	
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_RECEIVING:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Receive & run RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			
			}//if

			// check if the time to show the message has passed or if the user has pressed any key
			if (DATA_IO_1KXmodem_rom_receive()>=0){
						
				// load the dialog that informs that the RAM buffer content has been successfully received
				SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RUN_RAM,SCREEN_DIALOG_RECEIVE_RUN_RAM_RECEIVED);
							
			}else{
				
				// load the dialog that informs that there was an error while receiving RAM buffer content
				SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RUN_RAM,SCREEN_DIALOG_RECEIVE_RUN_RAM_PROCESS_ERROR);
				
			}//if
			break;

		case SCREEN_DIALOG_RECEIVE_RUN_RAM_RECEIVED:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Receive & run RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
				
		        // enable again CONSOLE module
		        CONSOLE_enable();				
				
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load the dialog that shows the dialog on which the system keeps receiving RAM buffer content
					SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RUN_RAM,SCREEN_DIALOG_RECEIVE_RUN_RAM_RUNNING);
				
			}//if	
			break;	
			
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_TIMEOUT_ERROR:
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_PROCESS_ERROR:
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_CANCELLED:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Receive & run RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();

		        // enable again CONSOLE module
		        CONSOLE_enable();
			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
				
			}//if	
			break;
								
		case SCREEN_DIALOG_RECEIVE_RUN_RAM_RUNNING:
	
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// lines commented because the title and help are the same than the
				// previous screen and there is no need to rewrite them ( it causes
				// an undesired flicker )			
				// print in screen the title of the new loaded menu
				// SCREENS_print_title(ui8_dpack_title_buffer,0);		
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("RAM running. Press song",0);
				SCREENS_print_help("stop and then any key.",1);
		
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
			    SCREENS_dialog_show();
			
			}//if

			// switch on the YELLOW LED to indicate that the system is busy emulating the cart
			GPIO_SetCtrlLinesOutput(VAR_CTRL_GPIO03);

			// to grant proper assembly execution and signals timings while reading the ROM Pack content, disable all
			// interrupts and keep only the interrupts used to detect changes on the ROM pack CLCK2 line
			GPIO_KeepOnlyDrivePackInterrupts();

			// bus initialization: start with control lines. When emulating the ROM PACK ctrl lines stay always in input mode
			config_ctrl_lines_as_input();     // call function to set CTRL lines to INPUT
			config_data_lines_as_input();	  // call function to set DATA lines to INPUT
			
			// ################ begin: call assembly routine that emulates ROM PACK until any key is pressed
			while ((PORT->Group[0].IN.reg&P0_USER_IFACE_PUSHB_ANY)==P0_USER_IFACE_PUSHB_ANY){
				dpack_int_main();
			}//while
			// ################ end: call assembly routine that emulates ROM PACK

			// once the ROM Pack has been emulated then restore interrupts, and disable the interrupts used to
			// sample ROM Pack CLKC1 and CLCK2 signals
			GPIO_RestoreAllSystemInterrupts();
			
			// switch off the YELLOW LED and others used to indicate that the system has stopped emulating the cart
			GPIO_SetCtrlLinesOutput(0x00);
					
			// load the structure of the menu pointed by menu_to_jump
			SCREENS_menus_load(SCREEN_MENU_CURRENT);
					
			break;
					
		default:
			i8_ret_val = -1;
			break;

	}//switch
	
	return i8_ret_val;
	
}//SCREENS_dialog_ev_manager_RECEIVE_RUN_RAM



int8_t SCREENS_dialog_load_RECEIVE_RAM(){
	int8_t i8_ret_val = 1;


	// update the current dialog screen
	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_RECEIVE_RAM_WAITING:
		    ui8_usart_1kX_retries = USART_1KXMODEM_RX_RETRIES;			
			screens_dialog.timer = TIMING_SetTicksDelay(0);// use dialog timer to manage 1kXmodem conection timeouts and retries
			break;
	
		case SCREEN_DIALOG_RECEIVE_RAM_RECEIVING:
			break;	

		case SCREEN_DIALOG_RECEIVE_RAM_RECEIVED:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);// use dialog timer to manage 1kXmodem conection timeouts and retries		
			break;
	
		case SCREEN_DIALOG_RECEIVE_RAM_TIMEOUT_ERROR:
		case SCREEN_DIALOG_RECEIVE_RAM_PROCESS_ERROR:
		case SCREEN_DIALOG_RECEIVE_RAM_CANCELLED:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);// use dialog timer to manage 1kXmodem conection timeouts and retries
			break;		
		
		default:
			i8_ret_val = -1;
			break;
		
	}//switch

	return i8_ret_val;

}//SCREENS_dialog_load_RECEIVE_RAM



int8_t SCREENS_dialog_show_RECEIVE_RAM(uint8_t * ui8_message){
	int8_t i8_ret_val = 1;
	uint8_t ui8_aux_string[AUX_FUNCS_F_P_MAX_STR_SIZE_64];
	uint8_t ui8_aux_string2[AUX_FUNCS_F_P_MAX_STR_SIZE_16];

	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_RECEIVE_RAM_WAITING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"   Use  send option  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)" in remote  computer.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Waiting to start  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"    receiving  RAM   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"   buffer content... ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the number of start transmission retries centered
			AUX_FUNCS_itoa((int32_t)ui8_usart_1kX_retries,ui8_aux_string2,10,AUX_FUNCS_F_P_MAX_STR_SIZE_16);
			AUX_FUNCS_lstrfill(ui8_aux_string,' ',GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
			AUX_FUNCS_center_into_string(ui8_aux_string,ui8_aux_string2,0,GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
			GRAPHIX_text_buffer_set_string(0,9,(uint8_t*)ui8_aux_string,ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
						
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
			
		case SCREEN_DIALOG_RECEIVE_RAM_RECEIVING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"     Connection ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"    established. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Receiving RAM ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"   buffer content.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"      Wait...",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;		
				
		case SCREEN_DIALOG_RECEIVE_RAM_RECEIVED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"  RAM buffer content ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"     successfully  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"    received  from ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"   remote computer. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;	

		case SCREEN_DIALOG_RECEIVE_RAM_TIMEOUT_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"   Error, connection  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   timeout.Could not  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  establish connection",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"      with remote     ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"       computer.      ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
			
		case SCREEN_DIALOG_RECEIVE_RAM_PROCESS_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"     Error while  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"    receiving RAM ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"   buffer content.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;			

		case SCREEN_DIALOG_RECEIVE_RAM_CANCELLED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  Receive RAM buffer ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  content cancelled. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;


		default:
			i8_ret_val = -1;
			break;
		
	}//switch

	return i8_ret_val;
	
}//SCREENS_dialog_show_RECEIVE_RAM



int8_t SCREENS_dialog_ev_manager_RECEIVE_RAM(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	int8_t i8_ret_val = 1;


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_RECEIVE_RAM_WAITING:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Receive RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			
				// disable CONSOLE module to avoid undesired interactions on the serial
				// port while sending the ROM in RAM buffer through the 1KXmodemConnection
				CONSOLE_disable();			
			
			}//if

			// check if the time to show the message has passed or if the user has pressed any key
			if ( /*TIMING_CheckTicksDelayReached(screens_dialog.timer) ||*/
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
		
					// load dialog that shows that the user has cancelled current receive operation
					SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RAM,SCREEN_DIALOG_RECEIVE_RAM_CANCELLED);
		
			}//if
			
			// waiting on each USART_1KXmodem_rx_establish iteration 
			if (TIMING_CheckTicksDelayReached(screens_dialog.timer)){
				
				i8_ret_val = (int8_t)USART_1KXmodem_rx_open();
				if (i8_ret_val==USART_1KX_TOUT_ERR){
					
					screens_dialog.timer = TIMING_SetTicksDelay(TIMMING_TICKS_1_S);	
					ui8_usart_1kX_retries--;
					if (ui8_usart_1kX_retries>0){
										
						// refresh the screen with current number of retries
						SCREENS_dialog_show();
								
					}else{
													
						// load dialog that shows the corresponding start connection timeout error
						SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RAM,SCREEN_DIALOG_RECEIVE_RAM_TIMEOUT_ERROR);
									
					}//if
										
				}else{
					
					// check if the first 1KXmodem packet that confirms that 1KXmodem connection has been established has been received
					if (i8_ret_val == USART_1KX_PACKET_OK){
														
						// load the dialog on which the system keeps receiving the ROM content sent by the sender
						SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RAM,SCREEN_DIALOG_RECEIVE_RAM_RECEIVING);
															
					}else{
						
					    // load the dialog that shows the corresponding reception error message
						SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RAM,SCREEN_DIALOG_RECEIVE_RAM_PROCESS_ERROR);
									
					}//if

				}//if
					
			}//if					
			break;
	
		case SCREEN_DIALOG_RECEIVE_RAM_RECEIVING:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Receive RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			
			}//if

			// check if the time to show the message has passed or if the user has pressed any key
			if (DATA_IO_1KXmodem_rom_receive()>=0){
						
				// load the dialog that informs that the RAM buffer content has been successfully received (from remote computer)
				SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RAM,SCREEN_DIALOG_RECEIVE_RAM_RECEIVED);
							
			}else{
				
				// load the dialog that informs about an error while receiving RAM buffer content
				SCREENS_dialog_load(SCREEN_DIALOG_ID_RECEIVE_RAM,SCREEN_DIALOG_RECEIVE_RAM_PROCESS_ERROR);
				
			}//if
			break;

		case SCREEN_DIALOG_RECEIVE_RAM_RECEIVED:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Receive RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
				
		        // enable again CONSOLE module
		        CONSOLE_enable();				
				
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
				
			}//if	
			break;	
			
		case SCREEN_DIALOG_RECEIVE_RAM_TIMEOUT_ERROR:
		case SCREEN_DIALOG_RECEIVE_RAM_PROCESS_ERROR:
		case SCREEN_DIALOG_RECEIVE_RAM_CANCELLED:		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Receive RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();

		        // enable again CONSOLE module
		        CONSOLE_enable();
			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
				
			}//if	
			break;		
			
		default:
			i8_ret_val = -1;
			break;

	}//switch
	
	return i8_ret_val;
	
}//SCREENS_dialog_ev_manager_RECEIVE_RAM



int8_t SCREENS_dialog_load_SEND_RAM(){
	int8_t i8_ret_val = 1;

	// update the current dialog screen
	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_SEND_RAM_CHECK:
			break;
			
		case SCREEN_DIALOG_SEND_RAM_WAITING:
		    ui8_usart_1kX_retries = USART_1KXMODEM_RX_RETRIES;
		    screens_dialog.timer = TIMING_SetTicksDelay(0);// use dialog timer to manage 1kXmodem connection timeouts and retries
			break;
		
		case SCREEN_DIALOG_SEND_RAM_SENDING:
			break;

		case SCREEN_DIALOG_SEND_RAM_SENT:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);// use dialog timer to manage 1kXmodem connection timeouts and retries
			break;
		
		case SCREEN_DIALOG_SEND_RAM_TIMEOUT_ERROR:
		case SCREEN_DIALOG_SEND_RAM_PROCESS_ERROR:
		case SCREEN_DIALOG_SEND_RAM_NO_LOADED_ERROR:
		case SCREEN_DIALOG_SEND_RAM_CANCELLED:
			screens_dialog.timer = TIMING_SetTicksDelay(SCREEN_DIALOG_SHOW_SLOWEST_MESSAGE_TIMEOUT);// use dialog timer to manage 1kXmodem connection timeouts and retries
			break;

		default:
			i8_ret_val = -1;
			break;
		
	}//switch

	return i8_ret_val;

}//SCREENS_dialog_load_SEND_RAM



int8_t SCREENS_dialog_show_SEND_RAM(uint8_t * ui8_message){
	int8_t i8_ret_val = 1;
	uint8_t ui8_aux_string[AUX_FUNCS_F_P_MAX_STR_SIZE_64];
	uint8_t ui8_aux_string2[AUX_FUNCS_F_P_MAX_STR_SIZE_16];

	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_SEND_RAM_CHECK:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"  Checking  if there  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   is valid data in   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  RAM buffer to send. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"       Wait ...       ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
		
		case SCREEN_DIALOG_SEND_RAM_WAITING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"  Use receive option ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)" in remote  computer.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);		
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Waiting to start ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"     sending  RAM   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"   buffer content...",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the number of start transmission retries centered
			AUX_FUNCS_itoa((int32_t)ui8_usart_1kX_retries,ui8_aux_string2,10,AUX_FUNCS_F_P_MAX_STR_SIZE_16);
			AUX_FUNCS_lstrfill(ui8_aux_string,' ',GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 is lower than AUX_FUNCS_F_P_MAX_STR_SIZE
			AUX_FUNCS_center_into_string(ui8_aux_string,ui8_aux_string2,0,GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 is lower than AUX_FUNCS_F_P_MAX_STR_SIZE
			GRAPHIX_text_buffer_set_string(0,9,(uint8_t*)ui8_aux_string,ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
		
		case SCREEN_DIALOG_SEND_RAM_SENDING:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"    Connection ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"    established. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"    Sending RAM ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"   buffer content.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"      Wait...",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;		
				
		case SCREEN_DIALOG_SEND_RAM_SENT:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  RAM buffer content ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  successfully  sent ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  to remote computer.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;	

		case SCREEN_DIALOG_SEND_RAM_TIMEOUT_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"  Error, connection   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)" timeout.  Could not  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)" establish connection ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"     with remote      ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"      computer.       ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
			
		case SCREEN_DIALOG_SEND_RAM_PROCESS_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"     Error while  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"     sending RAM ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"   buffer content.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;	
			
		case SCREEN_DIALOG_SEND_RAM_NO_LOADED_ERROR:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  Error, there is no  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"  valid data  in RAM  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"    buffer to send.   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;	

		case SCREEN_DIALOG_SEND_RAM_CANCELLED:
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   Send RAM buffer   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"  content cancelled. ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;
				
		default:
			i8_ret_val = -1;
			break;
		
	}//switch

	return i8_ret_val;
	
}//SCREENS_dialog_show_SEND_RAM



int8_t SCREENS_dialog_ev_manager_SEND_RAM(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	int8_t i8_ret_val = 1;
	int16_t i16_aux=0;


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_SEND_RAM_CHECK:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Send RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
			
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			    
				// disable CONSOLE module to avoid undesired interactions on the serial 
				// port while sending the ROM in RAM buffer through the 1KXmodemConnection
				CONSOLE_disable();
				
			}//if
			
			// check the flag that indicates if there is valid data in the memory buffer and show the corresponding message
			if (ui8_dpack_dumper_buffer_initialized == FALSE){
					
				// load dialog that shows that there is no valid data loaded into memory buffer
				SCREENS_dialog_load(SCREEN_DIALOG_ID_SEND_RAM,SCREEN_DIALOG_SEND_RAM_NO_LOADED_ERROR);
					
			}else{
					
				// load the dialog on which the systems waits for the code that receiver sends to confirm that is ready to start receiving data packets 
				SCREENS_dialog_load(SCREEN_DIALOG_ID_SEND_RAM,SCREEN_DIALOG_SEND_RAM_WAITING);
					
			}//if
		    break;
			
		case SCREEN_DIALOG_SEND_RAM_WAITING:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Send RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
			
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			
			}//if

			// check if the time to show the message has passed or if the user has pressed any key
			if ( /*TIMING_CheckTicksDelayReached(screens_dialog.timer) ||*/
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
		
					// load dialog that shows that the user has cancelled SEND operation
					SCREENS_dialog_load(SCREEN_DIALOG_ID_SEND_RAM,SCREEN_DIALOG_SEND_RAM_CANCELLED);
		
			}//if
			
			// waiting on each USART_1KXmodem_tx_open iteration 
			if (TIMING_CheckTicksDelayReached(screens_dialog.timer)){
				
				i8_ret_val = (int8_t)USART_1KXmodem_tx_open();
				if (i8_ret_val==USART_1KX_TOUT_ERR){
					
					screens_dialog.timer = TIMING_SetTicksDelay(TIMMING_TICKS_1_S);	
					ui8_usart_1kX_retries--;
					if (ui8_usart_1kX_retries>0){
										
						// refresh the screen with current number of retries
						SCREENS_dialog_show();
										
					}else{
																
						// load dialog that shows the corresponding start connection timeout error
						SCREENS_dialog_load(SCREEN_DIALOG_ID_SEND_RAM,SCREEN_DIALOG_SEND_RAM_TIMEOUT_ERROR);
											
					}//if
										
				}else{
					
					// check that the USART_1KX_CHAR_C_OK byte code that receiver should send to indicate that he 
					// is ready to start transmission has been received 
					if (i8_ret_val == USART_1KX_CHAR_C_OK){
													
						// load the dialog on which the system keeps sending the rom to the remote computer
						SCREENS_dialog_load(SCREEN_DIALOG_ID_SEND_RAM,SCREEN_DIALOG_SEND_RAM_SENDING);
															
					}else{
						
					    // load the dialog that shows the corresponding sending error message
						SCREENS_dialog_load(SCREEN_DIALOG_ID_SEND_RAM,SCREEN_DIALOG_SEND_RAM_PROCESS_ERROR);
							
					}//if

				}//if
					
			}//if					
			break;
	
		case SCREEN_DIALOG_SEND_RAM_SENDING:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Send RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
			
			}//if
			
			// send RAM buffer content to the remote computer
			i16_aux = DATA_IO_1KXmodem_rom_send();
			if (i16_aux>=0){
				
				// load the dialog that shows that the current RAM buffer content has been 
				// succesfully sent (to remote computer)
				SCREENS_dialog_load(SCREEN_DIALOG_ID_SEND_RAM,SCREEN_DIALOG_SEND_RAM_SENT);
				
			}else{
				
				// load the dialog that shows there was an error while sending current RAM buffer content
				SCREENS_dialog_load(SCREEN_DIALOG_ID_SEND_RAM,SCREEN_DIALOG_SEND_RAM_PROCESS_ERROR);
				
			}//if
			break;

		case SCREEN_DIALOG_SEND_RAM_SENT:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Send RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
				
		        // enable again CONSOLE module	
				CONSOLE_enable();
			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
				
			}//if	

			break;	
			
		case SCREEN_DIALOG_SEND_RAM_TIMEOUT_ERROR:
		case SCREEN_DIALOG_SEND_RAM_PROCESS_ERROR:
		case SCREEN_DIALOG_SEND_RAM_NO_LOADED_ERROR:
		case SCREEN_DIALOG_SEND_RAM_CANCELLED:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Send RAM buffer" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Wait or press any key",0);
				SCREENS_print_help("to leave.",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
				
		        // enable again CONSOLE module
		        CONSOLE_enable();
							
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( TIMING_CheckTicksDelayReached(screens_dialog.timer) ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
					pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
				
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
				
			}//if	

			break;
				
		default:
			i8_ret_val = -1;
			break;
		
	}//switch
	
	return i8_ret_val;
	
}//SCREENS_dialog_ev_manager_SEND_RAM




int8_t SCREENS_dialog_load_TEST(){
	int8_t i8_ret_val = 1;

	// update the current dialog screen
	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:	
		case SCREEN_DIALOG_TEST_DEAD_PIXELS:
			break;

		case SCREEN_DIALOG_TEST_COLORS:
			break;
		
		case SCREEN_DIALOG_TEST_CTRLS:
			break;
			
		case SCREEN_DIALOG_TEST_DISK_UNIT_START:
			break;
		
		case SCREEN_DIALOG_TEST_DISK_UNIT:
			break;
			
		case SCREEN_DIALOG_TEST_LED_GREEN:
			break;
			
		case SCREEN_DIALOG_TEST_LED_YELLOW:
			break;
			
		case SCREEN_DIALOG_TEST_LED_RED:
			break;
					
		case SCREEN_DIALOG_TEST_USB_COMS:
			break;

		default:
			i8_ret_val = -1;
			break;
		
	}//switch

	return i8_ret_val;

}//SCREENS_dialog_load_TEST



int8_t SCREENS_dialog_show_TEST(uint8_t * ui8_message){
	int8_t i8_ret_val = 1;
	uint8_t ui8_aux_string[AUX_FUNCS_F_P_MAX_STR_SIZE_64];
	uint8_t ui8_aux_string2[AUX_FUNCS_F_P_MAX_STR_SIZE_64];
    uint32_t ui32_aux = 0;


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_TEST_DEAD_PIXELS:

			// paint the screen with white color to help detecting dead pixels
			LCD_ST7735_fast_fill (LCD_COLOR_WHITE, 0,0, 159, 127);		    
		    GRAPHIX_print_string(10, 51, 1, 1, LCD_COLOR_WHITE, LCD_COLOR_RED, "Look for dead pixels.");
			GRAPHIX_print_string(42, 76, 1, 1, LCD_COLOR_WHITE, LCD_COLOR_RED, "Press '->'");
			GRAPHIX_print_string(38, 86, 1, 1, LCD_COLOR_WHITE, LCD_COLOR_RED, "to continue.");

			break;

		case SCREEN_DIALOG_TEST_COLORS:
		
			// paint the rainbow colors to test the LCD colors
			LCD_ST7735_fast_fill ((uint16_t) 0xF800,  0,0,26,127);//RED
			LCD_ST7735_fast_fill ((uint16_t) 0xFD60, 26,0,52,127);//ORANGE
			LCD_ST7735_fast_fill ((uint16_t) 0xFFA0, 52,0,78,127);//YELLOW
			LCD_ST7735_fast_fill ((uint16_t) 0x0400, 78,0,104,127);//GREEN
			LCD_ST7735_fast_fill ((uint16_t) 0x017C,104,0,130,127);//BLUE
			LCD_ST7735_fast_fill ((uint16_t) 0xB017,130,0,160,127);//PURPLE           
			GRAPHIX_print_string(24, 51, 1, 1, LCD_COLOR_WHITE, LCD_COLOR_RED, "Check RGB colors.");
		    GRAPHIX_print_string(42, 76, 1, 1, LCD_COLOR_WHITE, LCD_COLOR_RED, "Press '->'");
		    GRAPHIX_print_string(38, 86, 1, 1, LCD_COLOR_WHITE, LCD_COLOR_RED, "to continue.");

			break;
		
		case SCREEN_DIALOG_TEST_CTRLS:

			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"    Press  buttons   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"    and roll knob.  ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();

			break;
				
		case SCREEN_DIALOG_TEST_DISK_UNIT_START:

			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"   Checking SD card ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"  unit. Insert an SD",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"    card and then   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"    press '->' to   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"      continue.     ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();

			break;
		
		case SCREEN_DIALOG_TEST_DISK_UNIT:

			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)" Reading the SD card.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"      Wait...   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			break;		

		case SCREEN_DIALOG_TEST_DISK_UNIT_OK:

			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,2,(uint8_t*)"     SD card unit    ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)" successfully loaded.",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			
			// get and print the label of the mounted unit
            GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"      Label is:      ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);          			
            if (FILE_SYS_get_label(ui8_aux_string2,&ui32_aux)>=0){				
				// check if the label of the mounted unit is defined ( is different of "")
				if (AUX_FUNCS_lstrlen(ui8_aux_string2,AUX_FUNCS_F_P_MAX_STR_SIZE_64)<=0){
				   // mounted label is "" so show the message informing that there is no label defined
                   GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"     not defined     ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);				
				}else{
				   // show the label of the unit
				   AUX_FUNCS_lstrfill(ui8_aux_string,' ',GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE				
				   AUX_FUNCS_center_into_string(ui8_aux_string,ui8_aux_string2,0,GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
				   GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)ui8_aux_string,ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
				}//if				
			}else{
			   // an error ocurred while getting the unit label	
               GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"       error",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);	
			}//if
			
			// get the size of mounted unit
            GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"   Size in MBs is:   ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_SUCCESS,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);          						
			if (FILE_SYS_get_unit_size_MBs(&ui32_aux)<0){
			    // mounted label is "" so show the message informing that there is no label defined
			    GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"        ??           ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			}else{
				// show the size of the unit
				AUX_FUNCS_lstrfill(ui8_aux_string,' ',GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
				AUX_FUNCS_itoa(ui32_aux,ui8_aux_string2,10,AUX_FUNCS_F_P_MAX_STR_SIZE_64);
				AUX_FUNCS_center_into_string(ui8_aux_string,ui8_aux_string2,0,GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1); // important GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1 << AUX_FUNCS_F_P_MAX_STR_SIZE
				GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)ui8_aux_string,ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			}//if
				
			// refresh the content of the buffer to screen					
			GRAPHIX_text_buffer_refresh();

			break;	

		case SCREEN_DIALOG_TEST_DISK_UNIT_ERROR:
		
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"   Error, it has not ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,4,(uint8_t*)"   been possible  to ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,5,(uint8_t*)"   access  to the SD ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,6,(uint8_t*)"      card unit.     ",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_ERROR,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();			
			
			break;
			
		case SCREEN_DIALOG_TEST_LED_GREEN:
			
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"      Check that",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(7,5,(uint8_t*)" GREEN ", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_GREEN,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"      LED is ON.", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			
			break;	
			
		case SCREEN_DIALOG_TEST_LED_YELLOW:
			
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"      Check that",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(6,5,(uint8_t*)" YELLOW ", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_YELLOW,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"      LED is ON.", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			
			break;
			
		case SCREEN_DIALOG_TEST_LED_RED:
		
			// clear the screen buffer content by filling it with the SCREENS_DIALOG_BACKGROUND_CHAR char
			GRAPHIX_text_buffer_fill(SCREENS_DIALOG_BACKGROUND_CHAR,ATTR_NO_ATTRIBS,GRAPHIX_TEXT_COL_IDX_DARK_GREY,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// set the message in the screen buffer
			GRAPHIX_text_buffer_set_string(0,3,(uint8_t*)"      Check that",ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(8,5,(uint8_t*)" RED ", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_RED,GRAPHIX_TEXT_COL_IDX_BLACK);
			GRAPHIX_text_buffer_set_string(0,7,(uint8_t*)"      LED is ON.", ATTR_SPACE_BACKSYMBOL,GRAPHIX_TEXT_COL_NEUTRAL,GRAPHIX_TEXT_COL_IDX_BLACK,GRAPHIX_TEXT_COL_IDX_BLACK);
			// refresh the content of the buffer to screen
			GRAPHIX_text_buffer_refresh();
			
			break;					

		case SCREEN_DIALOG_TEST_USB_COMS:

			break;	
				
		default:
			i8_ret_val = -1;
			break;
		
	}//switch

	return i8_ret_val;
	
}//SCREENS_dialog_show_TEST



int8_t SCREENS_dialog_ev_manager_TEST(int16_t * pi16_encoders_var_value, uint8_t * pui8_pushbutton_values){
	int8_t i8_ret_val = 1;
	int16_t i16_aux=0;


	switch (screens_dialog.i8_state){
		
		case SCREEN_DIALOG_INITIAL_STATE:
		case SCREEN_DIALOG_TEST_DEAD_PIXELS:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			    			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( /*TIMING_CheckTicksDelayReached(screens_dialog.timer) ||*/
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
		
					SCREENS_dialog_load(SCREEN_DIALOG_ID_TEST,SCREEN_DIALOG_TEST_COLORS);
		
			}//if			
			break;		
			
		case SCREEN_DIALOG_TEST_COLORS:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
			
				// show current dialog screen
				SCREENS_dialog_show();
			    			
			}//if
			
			// if any key is pressed move to next screen
			if ( /*TIMING_CheckTicksDelayReached(screens_dialog.timer) ||*/
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
		
					// clear the complete screen
					LCD_ST7735_fast_fill (LCD_COLOR_BLACK, 0,0, 159, 127);
					
					// set the REFRESH attribute of all characters of the buffer to '1' to
					// force them to be rewritten is screen
					GRAPHIX_text_buffer_fill_attr(ATTR_REFRESH);		
		
					SCREENS_dialog_load(SCREEN_DIALOG_ID_TEST,SCREEN_DIALOG_TEST_CTRLS);
		
			}//if			
			break;
			
		case SCREEN_DIALOG_TEST_CTRLS:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Test system" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Press '->' to continue.",0);
				SCREENS_print_help("",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
			    				
			}//if
						
			if (pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED){
		
				GRAPHIX_print_string(12, 67, 2, 2, LCD_COLOR_BLACK, LCD_COLOR_WHITE, "  BUT  1  ");
		
			}//if

			if ( pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED ){
				
				GRAPHIX_print_string(12, 67, 2, 2, LCD_COLOR_BLACK, LCD_COLOR_WHITE, "  BUT  2  ");
				
			}//if

			if (pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED){
				
				GRAPHIX_print_string(12, 67, 2, 2, LCD_COLOR_BLACK, LCD_COLOR_WHITE, "  BUT  3  ");
                
			}//if


			if (pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED ){
				
				GRAPHIX_print_string(12, 67, 2, 2, LCD_COLOR_BLACK, LCD_COLOR_WHITE, " ENC  BUT ");
				
			}//if	

			if (pi16_encoders_var_value[USER_IFACE_ENC_1]>0){
				
				GRAPHIX_print_string(12, 67, 2, 2, LCD_COLOR_BLACK, LCD_COLOR_WHITE, "  ENC UP  ");
				
			}//if
			
			if (pi16_encoders_var_value[USER_IFACE_ENC_1]<0){
				
				GRAPHIX_print_string(12, 67, 2, 2, LCD_COLOR_BLACK, LCD_COLOR_WHITE, " ENC DOWN ");
				
			}//if			
			
			if (pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED){
				
				// set the REFRESH attribute of all characters of the buffer to '1' to
				// force them to be rewritten is screen
				GRAPHIX_text_buffer_fill_attr(ATTR_REFRESH);
								
				SCREENS_dialog_load(SCREEN_DIALOG_ID_TEST,SCREEN_DIALOG_TEST_DISK_UNIT_START);
				
			}//if						
		    break;
				
		case SCREEN_DIALOG_TEST_DISK_UNIT_START:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// print in screen the title of the new loaded menu
				SCREENS_print_title("Test system" ,0);
				// update the help content lines in screen according to new loaded menu
				SCREENS_print_help("Press '->' to continue.",0);
				SCREENS_print_help("",1);
				
				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
			    			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( /*TIMING_CheckTicksDelayReached(screens_dialog.timer) ||*/
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
		
					SCREENS_dialog_load(SCREEN_DIALOG_ID_TEST,SCREEN_DIALOG_TEST_DISK_UNIT);
		
			}//if			
			break;
		
		case SCREEN_DIALOG_TEST_DISK_UNIT:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
			    			
			}//if
			
			i16_aux=FILE_SYS_mount("", 1);
			if (i16_aux<0){
					
				// load dialog that shows unit mount error
				SCREENS_dialog_load(SCREEN_DIALOG_ID_TEST,SCREEN_DIALOG_TEST_DISK_UNIT_ERROR);						
				 
			}else{

				i16_aux = FILE_SYS_dir_open("");
				if (i16_aux<0){
						
					// load dialog that shows the open directory error 
					SCREENS_dialog_load(SCREEN_DIALOG_ID_TEST,SCREEN_DIALOG_TEST_DISK_UNIT_ERROR);
					
				}else{
						
					// load dialog that shows that the SD card unit is OK
					SCREENS_dialog_load(SCREEN_DIALOG_ID_TEST, SCREEN_DIALOG_TEST_DISK_UNIT_OK);
						
				}//if				 

			}//if							
			break;

		case SCREEN_DIALOG_TEST_DISK_UNIT_OK:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
			    			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( /*TIMING_CheckTicksDelayReached(screens_dialog.timer) ||*/
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
		
					SCREENS_dialog_load(SCREEN_DIALOG_ID_TEST,SCREEN_DIALOG_TEST_LED_GREEN);
		
			}//if	
			break;

		case SCREEN_DIALOG_TEST_DISK_UNIT_ERROR:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
			    			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( /*TIMING_CheckTicksDelayReached(screens_dialog.timer) ||*/
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
		
					SCREENS_dialog_load(SCREEN_DIALOG_ID_TEST,SCREEN_DIALOG_TEST_LED_GREEN);
		
			}//if	
			break;
			
		case SCREEN_DIALOG_TEST_LED_GREEN:
		    // in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
								
				GPIO_SetCtrlLinesOutput(VAR_CTRL_GPIO01);
				
				// show current dialog screen
				SCREENS_dialog_show();
			    			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( /*TIMING_CheckTicksDelayReached(screens_dialog.timer) ||*/
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
		
					SCREENS_dialog_load(SCREEN_DIALOG_ID_TEST,SCREEN_DIALOG_TEST_LED_YELLOW);
		
			}//if			
			break;
		
		case SCREEN_DIALOG_TEST_LED_YELLOW:
		    // in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
								
				GPIO_SetCtrlLinesOutput(VAR_CTRL_GPIO03);
				
				// show current dialog screen
				SCREENS_dialog_show();
			    			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( /*TIMING_CheckTicksDelayReached(screens_dialog.timer) ||*/
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
		
					SCREENS_dialog_load(SCREEN_DIALOG_ID_TEST,SCREEN_DIALOG_TEST_LED_RED);
		
			}//if			
			break;
		
		case SCREEN_DIALOG_TEST_LED_RED:
		    // in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				GPIO_SetCtrlLinesOutput(VAR_CTRL_GPIO02);
				
				// show current dialog screen
				SCREENS_dialog_show();
			    			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( /*TIMING_CheckTicksDelayReached(screens_dialog.timer) ||*/
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
		
					GPIO_SetCtrlLinesOutput(0x00);
		
					SCREENS_dialog_load(SCREEN_DIALOG_ID_TEST,SCREEN_DIALOG_TEST_USB_COMS);
		
			}//if		
			break;			
					
		case SCREEN_DIALOG_TEST_USB_COMS:
		
			// in the on-load event show screen for first time
			if (screens_control.ui8_on_load_event==TRUE){

				// reset the OnLoad event flag
				screens_control.ui8_on_load_event = FALSE;
				
				// show current dialog screen
				SCREENS_dialog_show();
			    			
			}//if
			
			// check if the time to show the message has passed or if the user has pressed any key
			if ( /*TIMING_CheckTicksDelayReached(screens_dialog.timer) ||*/
				pui8_pushbutton_values[USER_IFACE_PUSHBT_1]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_2]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_3]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_4]==USER_IFACE_PRESSED  ||
				pui8_pushbutton_values[USER_IFACE_PUSHBT_ENC]==USER_IFACE_PRESSED  ){
		
					// load the structure of the menu pointed by menu_to_jump
					SCREENS_menus_load(SCREEN_MENU_CURRENT);
		
			}//if				
			break;
				
		default:
			i8_ret_val = -1;
			break;
		
	}//switch
	
	return i8_ret_val;
	
}//SCREENS_dialog_ev_manager_TEST



void SCREENS_print_current_rom_info(){
		uint16_t ui16_col = 0;
		uint16_t ui16_row = 0;
		uint16_t ui16_char_count = 0;
		uint8_t ui8_invert_chars = FALSE;
		uint8_t ui8_aux = 0;

	
		ui16_row = 0;
		ui16_col = 0;
		ui16_char_count = 0;
		ui8_invert_chars = FALSE;
		while ((ui16_char_count<MAX_ROM_SONGS_INFO_BUFFER) && (ui8_dpack_songs_info_buffer[ui16_char_count]!='\0')){
				
			ui8_aux= ui8_dpack_songs_info_buffer[ui16_char_count];
			
			if (ui8_aux=='\r'){
					
				// carrier return: move cursor to screen column 0
				ui16_col=0;
				   
            }else if (ui8_aux=='\n'){
					
				// line feed: jump to next screen row
				if (ui16_row<(GRAPHIX_TEXT_BUFFER_MAX_ROWS-1)){
					ui16_row++;
				}
				   
            }else if (ui8_aux=='['){
					
				// enable color inversion. Characters between '[' and ']' are printed in inverted color
				ui8_invert_chars = TRUE;
					
			}else if (ui8_aux==']'){
					
				// disable color inversion. Only chars between '[' and ']' are printed in inverted color	
				ui8_invert_chars = FALSE;
					
			}else{
					
				// if it is a conventional char it is printed in the screen
				if (ui8_invert_chars==TRUE){
					GRAPHIX_text_buffer_set_char(ui16_col , ui16_row, ui8_aux, ATTR_NO_ATTRIBS, GRAPHIX_TEXT_COL_IDX_BLACK, GRAPHIX_TEXT_COL_NEUTRAL, GRAPHIX_TEXT_COL_IDX_BLACK);
				}else{
					GRAPHIX_text_buffer_set_char(ui16_col , ui16_row, ui8_aux, ATTR_SPACE_BACKSYMBOL, GRAPHIX_TEXT_COL_NEUTRAL, GRAPHIX_TEXT_COL_IDX_BLACK, GRAPHIX_TEXT_COL_IDX_BLACK);			
				}//if

				// move the char cursor to next position in the screen
				if (ui16_col<(GRAPHIX_TEXT_BUFFER_MAX_COLUMNS-1)){
					ui16_col++;
				}else{
					ui16_col=0;
					if (ui16_row<(GRAPHIX_TEXT_BUFFER_MAX_ROWS-1)){
						ui16_row++;
					}
				}//if
		
			}//if (ui8_aux='\n')
							
			ui16_char_count++;
				
		}//while
			
}//SCREENS_print_current_rom_info